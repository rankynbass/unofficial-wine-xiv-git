From 3e00a60d1f69eefebfe4af856735914a6c5ea56f Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Mon, 25 Mar 2024 00:54:57 +0200
Subject: [PATCH] De-steamify proton's wine

---
 dlls/advapi32/advapi.c          |  34 +++--
 dlls/kernelbase/process.c       |  15 ---
 dlls/ntdll/loader.c             |  38 +-----
 dlls/ntdll/unix/env.c           |   3 +-
 dlls/ntdll/unix/loader.c        | 128 +------------------
 dlls/ntdll/unix/signal_i386.c   |   7 -
 dlls/ntdll/unix/signal_x86_64.c |   7 -
 dlls/ntdll/unix/unix_private.h  |   1 -
 dlls/ntdll/unixlib.h            |   7 -
 dlls/shell32/shellpath.c        | 219 +++++++++++++++++++++++++++-----
 dlls/winex11.drv/window.c       |  15 +--
 loader/wine.inf.in              |  27 +---
 programs/wineboot/wineboot.c    |  33 +++++
 programs/winebrowser/main.c     |  16 ---
 programs/winedbg/debugger.h     |   2 -
 programs/winedbg/tgt_active.c   |  48 -------
 programs/winedbg/winedbg.c      |  10 +-
 17 files changed, 242 insertions(+), 368 deletions(-)

diff --git a/dlls/advapi32/advapi.c b/dlls/advapi32/advapi.c
index 127cec572..2284e92b2 100644
--- a/dlls/advapi32/advapi.c
+++ b/dlls/advapi32/advapi.c
@@ -44,15 +44,14 @@ WINE_DEFAULT_DEBUG_CHANNEL(advapi);
  */
 BOOL WINAPI GetUserNameA( LPSTR name, LPDWORD size )
 {
-    static const char steamuserA[] = {'s','t','e','a','m','u','s','e','r',0};
-    if(*size < ARRAY_SIZE(steamuserA)){
-        SetLastError( ERROR_INSUFFICIENT_BUFFER );
-        *size = ARRAY_SIZE(steamuserA);
-        return FALSE;
-    }
-    memcpy(name, steamuserA, sizeof(steamuserA));
-    *size = ARRAY_SIZE(steamuserA);
-    return TRUE;
+    DWORD len = GetEnvironmentVariableA( "WINEUSERNAME", name, *size );
+    BOOL ret;
+
+    if (!len) return FALSE;
+    if ((ret = (len < *size))) len++;
+    else SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    *size = len;
+    return ret;
 }
 
 /******************************************************************************
@@ -60,15 +59,14 @@ BOOL WINAPI GetUserNameA( LPSTR name, LPDWORD size )
  */
 BOOL WINAPI GetUserNameW( LPWSTR name, LPDWORD size )
 {
-    static const WCHAR steamuserW[] = {'s','t','e','a','m','u','s','e','r',0};
-    if(*size < ARRAY_SIZE(steamuserW)){
-        SetLastError( ERROR_INSUFFICIENT_BUFFER );
-        *size = ARRAY_SIZE(steamuserW);
-        return FALSE;
-    }
-    memcpy(name, steamuserW, sizeof(steamuserW));
-    *size = ARRAY_SIZE(steamuserW);
-    return TRUE;
+    DWORD len = GetEnvironmentVariableW( L"WINEUSERNAME", name, *size );
+    BOOL ret;
+
+    if (!len) return FALSE;
+    if ((ret = (len < *size))) len++;
+    else SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    *size = len;
+    return ret;
 }
 
 /******************************************************************************
diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index c2c46dd0a..29f5aa2b1 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -2507,7 +2507,6 @@ void WINAPI RtlSetLastWin32Error( DWORD err )
  */
 NTSTATUS WINAPI __wine_set_unix_env( const char *var, const char *val )
 {
-    if (!val) unsetenv(var);
-    else setenv(var, val, 1);
+    setenv(var, val, 1);
     return 0;
 }
diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index c384919fd..634fd944c 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -2639,6 +2639,183 @@ end:
     return hr;
 }
 
+static char *xdg_config;
+static DWORD xdg_config_len;
+
+static BOOL WINAPI init_xdg_dirs( INIT_ONCE *once, void *param, void **context )
+{
+    const WCHAR *var, *fmt = L"\\??\\unix%s/user-dirs.dirs";
+    char *p;
+    WCHAR *name, *ptr;
+    HANDLE file;
+    DWORD len;
+
+    if (!(var = _wgetenv( L"XDG_CONFIG_HOME" )) || var[0] != '/')
+    {
+        if (!(var = _wgetenv( L"WINEHOMEDIR" ))) return TRUE;
+        fmt = L"%s/.config/user-dirs.dirs";
+    }
+    len = lstrlenW(var) + lstrlenW(fmt);
+    name = heap_alloc( len * sizeof(WCHAR) );
+    swprintf( name, len, fmt, var );
+    name[1] = '\\';  /* change \??\ to \\?\ */
+    for (ptr = name; *ptr; ptr++) if (*ptr == '/') *ptr = '\\';
+
+    file = CreateFileW( name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0 );
+    heap_free( name );
+    if (file != INVALID_HANDLE_VALUE)
+    {
+        len = GetFileSize( file, NULL );
+        if (!(xdg_config = heap_alloc( len + 1 ))) return TRUE;
+        if (!ReadFile( file, xdg_config, len, &xdg_config_len, NULL ))
+        {
+            heap_free( xdg_config );
+            xdg_config = NULL;
+        }
+        else
+        {
+            for (p = xdg_config; p < xdg_config + xdg_config_len; p++) if (*p == '\n') *p = 0;
+            *p = 0;  /* append null to simplify string parsing */
+        }
+        CloseHandle( file );
+    }
+    return TRUE;
+}
+
+static char *get_xdg_path( const char *var )
+{
+    static INIT_ONCE once;
+    char *p, *ret = NULL;
+    int i;
+
+    InitOnceExecuteOnce( &once, init_xdg_dirs, NULL, NULL );
+    if (!xdg_config) return NULL;
+
+    for (p = xdg_config; p < xdg_config + xdg_config_len; p += strlen(p) + 1)
+    {
+        while (*p == ' ' || *p == '\t') p++;
+        if (strncmp( p, var, strlen(var) )) continue;
+        p += strlen(var);
+        while (*p == ' ' || *p == '\t') p++;
+        if (*p != '=') continue;
+        p++;
+        while (*p == ' ' || *p == '\t') p++;
+        if (*p != '"') continue;
+        p++;
+        if (*p != '/' && strncmp( p, "$HOME/", 6 )) continue;
+
+        if (!(ret = heap_alloc( strlen(p) + 1 ))) break;
+        for (i = 0; *p && *p != '"'; i++, p++)
+        {
+            if (*p == '\\' && p[1]) p++;
+            ret[i] = *p;
+        }
+        ret[i] = 0;
+        if (*p != '"')
+        {
+            heap_free( ret );
+            ret = NULL;
+        }
+        break;
+    }
+    return ret;
+}
+
+static BOOL link_folder( HANDLE mgr, const UNICODE_STRING *path, const char *link )
+{
+    struct mountmgr_shell_folder *ioctl;
+    DWORD len = sizeof(*ioctl) + path->Length + strlen(link) + 1;
+    BOOL ret;
+
+    if (!(ioctl = heap_alloc( len ))) return FALSE;
+    ioctl->create_backup = FALSE;
+    ioctl->folder_offset = sizeof(*ioctl);
+    ioctl->folder_size = path->Length;
+    memcpy( (char *)ioctl + ioctl->folder_offset, path->Buffer, ioctl->folder_size );
+    ioctl->symlink_offset = ioctl->folder_offset + ioctl->folder_size;
+    strcpy( (char *)ioctl + ioctl->symlink_offset, link );
+
+    ret = DeviceIoControl( mgr, IOCTL_MOUNTMGR_DEFINE_SHELL_FOLDER, ioctl, len, NULL, 0, NULL, NULL );
+    heap_free( ioctl );
+    return ret;
+}
+
+/******************************************************************************
+ * create_link
+ *
+ * Sets up a symbolic link for one of the 'My Whatever' shell folders to point
+ * into the corresponding XDG directory.
+ */
+static void create_link( const WCHAR *path, const char *xdg_name, const char *default_name )
+{
+    UNICODE_STRING nt_name;
+    char *target = NULL;
+    HANDLE mgr;
+
+    if ((mgr = CreateFileW( MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
+                            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
+                            0, 0 )) == INVALID_HANDLE_VALUE)
+    {
+        FIXME( "failed to connect to mount manager\n" );
+        return;
+    }
+
+    nt_name.Buffer = NULL;
+    if (!RtlDosPathNameToNtPathName_U( path, &nt_name, NULL, NULL )) goto done;
+
+    if ((target = get_xdg_path( xdg_name )))
+    {
+        if (link_folder( mgr, &nt_name, target )) goto done;
+    }
+    if (link_folder( mgr, &nt_name, default_name )) goto done;
+
+    /* fall back to HOME */
+    link_folder( mgr, &nt_name, "$HOME" );
+
+done:
+    RtlFreeUnicodeString( &nt_name );
+    heap_free( target );
+    CloseHandle( mgr );
+}
+
+/******************************************************************************
+ * _SHCreateSymbolicLink  [Internal]
+ *
+ * Sets up a symbolic link for one of the special shell folders to point into
+ * the users home directory.
+ *
+ * PARAMS
+ *  nFolder [I] CSIDL identifying the folder.
+ */
+static void _SHCreateSymbolicLink(int nFolder, const WCHAR *path)
+{
+    DWORD folder = nFolder & CSIDL_FOLDER_MASK;
+
+    switch (folder) {
+        case CSIDL_PERSONAL:
+            create_link( path, "XDG_DOCUMENTS_DIR", "$HOME/Documents" );
+            break;
+        case CSIDL_DESKTOPDIRECTORY:
+            create_link( path, "XDG_DESKTOP_DIR", "$HOME/Desktop" );
+            break;
+        case CSIDL_MYPICTURES:
+            create_link( path, "XDG_PICTURES_DIR", "$HOME/Pictures" );
+            break;
+        case CSIDL_MYVIDEO:
+            create_link( path, "XDG_VIDEOS_DIR", "$HOME/Movies" );
+            break;
+        case CSIDL_MYMUSIC:
+            create_link( path, "XDG_MUSIC_DIR", "$HOME/Music" );
+            break;
+        case CSIDL_DOWNLOADS:
+            create_link( path, "XDG_DOWNLOAD_DIR", "$HOME/Downloads" );
+            break;
+        case CSIDL_TEMPLATES:
+            create_link( path, "XDG_TEMPLATES_DIR", "$HOME/Templates" );
+            break;
+    }
+}
+
 /******************************************************************************
  * SHGetFolderPathW			[SHELL32.@]
  *
@@ -2827,6 +3004,10 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
         goto end;
     }
 
+    /* create symbolic links rather than directories for specific
+     * user shell folders */
+    _SHCreateSymbolicLink(folder, szBuildPath);
+
     /* create directory/directories */
     ret = SHCreateDirectoryExW(hwndOwner, szBuildPath, NULL);
     if (ret && ret != ERROR_ALREADY_EXISTS)
@@ -2881,8 +3062,6 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
  LPCWSTR szUserShellFolderPath, LPCWSTR szShellFolderPath, const UINT folders[],
  UINT foldersLen)
 {
-    static const WCHAR WineVistaPathsW[] = {'_','_','W','i','n','e','V','i','s','t','a','P','a','t','h','s',0};
-
     const WCHAR *szValueName;
     WCHAR buffer[40];
     UINT i;
@@ -2891,7 +3070,6 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
     HKEY hUserKey = NULL, hKey = NULL;
     DWORD dwType, dwPathLen;
     LONG ret;
-    DWORD already_vista_paths = 0;
 
     TRACE("%p,%p,%s,%p,%u\n", hRootKey, hToken,
      debugstr_w(szUserShellFolderPath), folders, foldersLen);
@@ -2905,12 +3083,6 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
         if (ret)
             hr = HRESULT_FROM_WIN32(ret);
     }
-
-    /* check if the registry has already been updated to the vista+ style paths */
-    dwPathLen = sizeof(already_vista_paths);
-    RegQueryValueExW(hUserKey, WineVistaPathsW, NULL, &dwType,
-            (LPBYTE)&already_vista_paths, &dwPathLen);
-
     for (i = 0; SUCCEEDED(hr) && i < foldersLen; i++)
     {
         dwPathLen = MAX_PATH * sizeof(WCHAR);
@@ -2923,10 +3095,9 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
             szValueName = &buffer[0];
         }
 
-        if (!already_vista_paths ||
-                RegQueryValueExW(hUserKey, szValueName, NULL, &dwType,
-                    (LPBYTE)path, &dwPathLen) ||
-                (dwType != REG_SZ && dwType != REG_EXPAND_SZ))
+        if (RegQueryValueExW(hUserKey, szValueName, NULL,
+         &dwType, (LPBYTE)path, &dwPathLen) || (dwType != REG_SZ &&
+         dwType != REG_EXPAND_SZ))
         {
             *path = '\0';
             if (CSIDL_Data[folders[i]].type == CSIDL_Type_User)
@@ -2967,11 +3138,6 @@ static HRESULT _SHRegisterFolders(HKEY hRootKey, HANDLE hToken,
              hToken, SHGFP_TYPE_DEFAULT, path);
         }
     }
-
-    already_vista_paths = 1;
-    RegSetValueExW(hUserKey, WineVistaPathsW, 0, REG_DWORD,
-            (LPBYTE)&already_vista_paths, sizeof(already_vista_paths));
-
     if (hUserKey)
         RegCloseKey(hUserKey);
     if (hKey)
@@ -3112,23 +3278,6 @@ static HRESULT create_extra_folders(void)
         hr = SHGetFolderPathAndSubDirW(0, CSIDL_APPDATA | CSIDL_FLAG_CREATE, NULL,
                                        SHGFP_TYPE_DEFAULT, L"Microsoft\\Windows\\Themes", path);
     }
-
-
-    /* Proton HACK: In older Proton versions, duplicate Stuff directories were
-     * created at both %PROFILE%\Music and %PROFILE\Documents\Music. Due to
-     * some bugs when downgrading to those older Proton versions, create those
-     * missing Documents directories here, too. */
-    SHGetFolderPathAndSubDirW(0, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL,
-                                   SHGFP_TYPE_DEFAULT, L"Downloads", path);
-    SHGetFolderPathAndSubDirW(0, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL,
-                                   SHGFP_TYPE_DEFAULT, L"Music", path);
-    SHGetFolderPathAndSubDirW(0, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL,
-                                   SHGFP_TYPE_DEFAULT, L"Pictures", path);
-    SHGetFolderPathAndSubDirW(0, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL,
-                                   SHGFP_TYPE_DEFAULT, L"Templates", path);
-    SHGetFolderPathAndSubDirW(0, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL,
-                                   SHGFP_TYPE_DEFAULT, L"Videos", path);
-
     return hr;
 }
 
diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index 0ea276f68..947a6eb8d 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -1433,6 +1433,37 @@ static BOOL start_services_process(void)
     return TRUE;
 }
 
+static INT_PTR CALLBACK wait_dlgproc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
+{
+    switch (msg)
+    {
+    case WM_INITDIALOG:
+        {
+            DWORD len;
+            WCHAR *buffer, text[1024];
+            const WCHAR *name = (WCHAR *)lp;
+            HICON icon = LoadImageW( 0, (LPCWSTR)IDI_WINLOGO, IMAGE_ICON, 48, 48, LR_SHARED );
+            SendDlgItemMessageW( hwnd, IDC_WAITICON, STM_SETICON, (WPARAM)icon, 0 );
+            SendDlgItemMessageW( hwnd, IDC_WAITTEXT, WM_GETTEXT, 1024, (LPARAM)text );
+            len = lstrlenW(text) + lstrlenW(name) + 1;
+            buffer = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+            swprintf( buffer, len, text, name );
+            SendDlgItemMessageW( hwnd, IDC_WAITTEXT, WM_SETTEXT, 0, (LPARAM)buffer );
+            HeapFree( GetProcessHeap(), 0, buffer );
+        }
+        break;
+    }
+    return 0;
+}
+
+static HWND show_wait_window(void)
+{
+    HWND hwnd = CreateDialogParamW( GetModuleHandleW(0), MAKEINTRESOURCEW(IDD_WAITDLG), 0,
+                                    wait_dlgproc, (LPARAM)prettyprint_configdir() );
+    ShowWindow( hwnd, SW_SHOWNORMAL );
+    return hwnd;
+}
+
 static HANDLE start_rundll32( const WCHAR *inf_path, const WCHAR *install, WORD machine )
 {
     WCHAR app[MAX_PATH + ARRAY_SIZE(L"\\rundll32.exe" )];
@@ -1632,6 +1663,7 @@ static void update_wineprefix( BOOL force )
 
         if ((process = start_rundll32( inf_path, L"PreInstall", IMAGE_FILE_MACHINE_TARGET_HOST )))
         {
+            HWND hwnd = show_wait_window();
             for (;;)
             {
                 if (process)
@@ -1652,6 +1684,7 @@ static void update_wineprefix( BOOL force )
                     process = start_rundll32( inf_path, L"Wow64Install", machines[count].Machine );
                 count++;
             }
+            DestroyWindow( hwnd );
         }
         install_root_pnp_devices();
         update_user_profile();
diff --git a/programs/winedbg/debugger.h b/programs/winedbg/debugger.h
index 74c935f42..c65b9bfae 100644
--- a/programs/winedbg/debugger.h
+++ b/programs/winedbg/debugger.h
@@ -311,8 +311,6 @@ extern	DWORD	                dbg_curr_tid;
 extern  dbg_ctx_t               dbg_context;
 extern  BOOL                    dbg_interactiveP;
 extern  HANDLE                  dbg_houtput;
-extern  HANDLE                  dbg_crash_report_file;
-extern  BOOL                    dbg_use_wine_dbg_output;
 
 struct dbg_internal_var
 {
diff --git a/programs/winedbg/tgt_active.c b/programs/winedbg/tgt_active.c
index 23652b777..175788571 100644
--- a/programs/winedbg/tgt_active.c
+++ b/programs/winedbg/tgt_active.c
@@ -22,8 +22,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
-#include <time.h>
-#include <sys/stat.h>
 
 #include "debugger.h"
 #include "psapi.h"
@@ -818,48 +816,6 @@ static HANDLE create_temp_file(void)
                         NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, 0 );
 }
 
-static HANDLE create_crash_report_file(void)
-{
-    const char *dir = getenv("WINE_CRASH_REPORT_DIR");
-    const char *sgi;
-    char timestr[32];
-    char name[MAX_PATH], *c;
-    time_t t;
-    struct tm lt;
-
-    if(!dir || dir[0] == 0)
-        return INVALID_HANDLE_VALUE;
-
-    strcpy(name, dir);
-
-    for(c = name + 1; *c; ++c){
-        if(*c == '/'){
-            *c = 0;
-            CreateDirectoryA(name, NULL);
-            *c = '/';
-        }
-    }
-    CreateDirectoryA(name, NULL);
-
-    sgi = getenv("SteamGameId");
-
-    t = time(NULL);
-    lt = *localtime(&t);
-    strftime(timestr, ARRAY_SIZE(timestr), "%Y-%m-%d_%H:%M:%S", &lt);
-
-    /* /path/to/crash/reports/2021-05-18_13:21:15_appid-976310_crash.log */
-    snprintf(name, ARRAY_SIZE(name),
-            "%s%s/%s_appid-%s_crash.log",
-            dir[0] == '/' ? "Z:/" : "",
-            dir,
-            timestr,
-            sgi ? sgi : "0"
-            );
-
-    return CreateFileA( name, GENERIC_WRITE, FILE_SHARE_READ,
-                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 );
-}
-
 /******************************************************************
  *		dbg_active_attach
  *
@@ -951,10 +907,6 @@ enum dbg_start dbg_active_auto(int argc, char* argv[])
         if (event) thread = display_crash_details( event );
         if (thread) dbg_houtput = output = create_temp_file();
         break;
-    case TRUE:
-        dbg_use_wine_dbg_output = TRUE;
-        dbg_crash_report_file = create_crash_report_file();
-        break;
     }
 
     input = parser_generate_command_file("echo Modules:", "info share",
diff --git a/programs/winedbg/winedbg.c b/programs/winedbg/winedbg.c
index 7769d2048..92fa77429 100644
--- a/programs/winedbg/winedbg.c
+++ b/programs/winedbg/winedbg.c
@@ -82,8 +82,6 @@ DWORD	                dbg_curr_pid = 0;
 dbg_ctx_t               dbg_context;
 BOOL    	        dbg_interactiveP = FALSE;
 HANDLE                  dbg_houtput = 0;
-HANDLE                  dbg_crash_report_file = INVALID_HANDLE_VALUE;
-BOOL                    dbg_use_wine_dbg_output = FALSE;
 
 static struct list      dbg_process_list = LIST_INIT(dbg_process_list);
 
@@ -96,9 +94,6 @@ static void dbg_outputA(const char* buffer, int len)
 
     DWORD w, i;
 
-    if (dbg_use_wine_dbg_output)
-        __wine_dbg_output(buffer);
-
     while (len > 0)
     {
         unsigned int count = min( len, sizeof(line_buff) - line_pos );
@@ -112,10 +107,7 @@ static void dbg_outputA(const char* buffer, int len)
             if (len > 0) i = line_pos;  /* buffer is full, flush anyway */
             else break;
         }
-        if (!dbg_use_wine_dbg_output)
-            WriteFile(dbg_houtput, line_buff, i, &w, NULL);
-        if (dbg_crash_report_file != INVALID_HANDLE_VALUE)
-            WriteFile(dbg_crash_report_file, line_buff, i, &w, NULL);
+        WriteFile(dbg_houtput, line_buff, i, &w, NULL);
         memmove( line_buff, line_buff + i, line_pos - i );
         line_pos -= i;
     }

