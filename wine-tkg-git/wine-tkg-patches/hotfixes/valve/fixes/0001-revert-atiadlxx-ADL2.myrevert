From 761730bb6df4feeec9307fe0b5684a39b02cca4c Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 2 Oct 2025 18:20:03 -0600
Subject: [PATCH] atiadlxx: Implement ADL[2]_Display_DisplayMapConfig_Get().

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   |  2 +-
 dlls/atiadlxx/atiadlxx_main.c | 60 +++++++++++++++++++++++++++++++++--
 2 files changed, 58 insertions(+), 4 deletions(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 785d5a93d11..532473b0d5a 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -259,7 +259,7 @@
 @ stub ADL2_Display_DisplayContent_Set
 @ cdecl ADL2_Display_DisplayInfo_Get(ptr long ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfigX2_Set
-@ stub ADL2_Display_DisplayMapConfig_Get
+@ cdecl ADL2_Display_DisplayMapConfig_Get(ptr long ptr ptr ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfig_PossibleAddAndRemove
 @ stub ADL2_Display_DisplayMapConfig_Set
 @ stub ADL2_Display_DisplayMapConfig_Validate
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 49260b24c75..1d840aa5a7b 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -1011,13 +1011,67 @@ int CDECL ADL_Graphics_Platform_Get(int *platform)
     return ADL2_Graphics_Platform_Get(default_ctx, platform);
 }
 
+int CDECL ADL2_Display_DisplayMapConfig_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
+        int *display_target_count, ADLDisplayTarget **display_targets, int options)
+{
+    struct gpu *gpu;
+    int i;
+
+    TRACE("ctx %p, adapter_index %d, display_map_count %p, display_maps %p, "
+            "display_target_count %p, display_targets %p, options %d.\n",
+            ctx, adapter_index, display_map_count, display_maps, display_target_count,
+            display_targets, options);
+
+    if (adapter_index >= ctx->adapter_count) return ADL_ERR_INVALID_ADL_IDX;
+    gpu = ctx->adapters[adapter_index].gpu;
+    if (!gpu->display_count) return ADL_ERR_NOT_SUPPORTED;
+    *display_map_count = gpu->display_count;
+    *display_maps = ctx->malloc(*display_map_count * sizeof(**display_maps));
+    memset(*display_maps, 0, *display_map_count * sizeof(**display_maps));
+    *display_target_count = gpu->display_count;
+    *display_targets = ctx->malloc(*display_target_count * sizeof(**display_targets));
+    memset(*display_targets, 0, *display_target_count * sizeof(**display_targets));
+
+    for (i = 0; i < gpu->display_count; ++i)
+    {
+        ADLMode *m = (ADLMode *)&(*display_maps)[i].displayMode;
+        DISPLAYCONFIG_SOURCE_MODE *dc_mode = &gpu->displays[i].mode;
+
+        (*display_maps)[i].iDisplayMapIndex = gpu->displays[i].logical_adapter_index;
+        (*display_maps)[i].iNumDisplayTarget = 1;
+        (*display_maps)[i].iFirstDisplayTargetArrayIndex = i;
+        (*display_maps)[i].iDisplayMapMask = 0xf;
+        (*display_maps)[i].iDisplayMapValue = 0x4; /* ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE */
+
+        m->displayID.iDisplayLogicalAdapterIndex = gpu->displays[i].logical_adapter_index;
+        m->displayID.iDisplayLogicalIndex = i;
+        m->iAdapterIndex = gpu->displays[i].logical_adapter_index;
+        m->iXPos = dc_mode->position.x;
+        m->iYPos = dc_mode->position.y;
+        m->iXRes = dc_mode->width;
+        m->iYRes = dc_mode->height;
+        m->iColourDepth = 32;
+        m->fRefreshRate = (float)gpu->displays[i].refresh_rate.Numerator / gpu->displays[i].refresh_rate.Denominator;
+        m->iOrientation = (gpu->displays[i].rotation - 1) * 90;
+        m->iModeMask = 0xff;
+        m->iModeValue = 0x46;
+
+        (*display_targets)[i].displayID = m->displayID;
+        (*display_targets)[i].iDisplayMapIndex = i;
+        (*display_targets)[i].iDisplayTargetMask = 1;
+        (*display_targets)[i].iDisplayTargetValue = 1;
+    }
+    return ADL_OK;
+}
+
 int CDECL ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
         int *display_target_count, ADLDisplayTarget **display_targets, int options)
 {
-    FIXME("adapter_index %d, display_map_count %p, display_maps %p, "
-            "display_target_count %p, display_targets %p, options %d stub.\n",
+    TRACE("adapter_index %d, display_map_count %p, display_maps %p, "
+            "display_target_count %p, display_targets %p, options %d.\n",
             adapter_index, display_map_count, display_maps, display_target_count,
             display_targets, options);
 
-    return ADL_ERR;
+    return ADL2_Display_DisplayMapConfig_Get(default_ctx, adapter_index, display_map_count, display_maps,
+            display_target_count, display_targets, options);
 }


From 7872905a4d924c788916a9591e8b89d74c4b3b33 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 2 Oct 2025 18:41:11 -0600
Subject: [PATCH] atiadlxx: Implement ADL2_Display_DDCInfo2_Get().

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   |   2 +-
 dlls/atiadlxx/atiadlxx_main.c | 132 ++++++++++++++++++++++++++++++++++
 2 files changed, 133 insertions(+), 1 deletion(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 5d44a20eb29..785d5a93d11 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -249,7 +249,7 @@
 @ stub ADL2_Display_DCE_Get
 @ stub ADL2_Display_DCE_Set
 @ stub ADL2_Display_DDCBlockAccess_Get
-@ stub ADL2_Display_DDCInfo2_Get
+@ cdecl ADL2_Display_DDCInfo2_Get(ptr long long ptr)
 @ stub ADL2_Display_DDCInfo_Get
 @ stub ADL2_Display_Deflicker_Get
 @ stub ADL2_Display_Deflicker_Set
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index c77bfd2ea3b..49260b24c75 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -196,6 +196,89 @@ typedef struct ADLDisplayMap
 
 #define ADL_MAX_DISPLAY_NAME 256
 
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB656           0x00000001
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB666           0x00000002
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888           0x00000004
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB101010        0x00000008
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB161616        0x00000010
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED1    0x00000020
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED2    0x00000040
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED3    0x00000080
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_XRGB_BIAS101010  0x00000100
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_8BPCC   0x00000200
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_10BPCC  0x00000400
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_12BPCC  0x00000800
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_8BPCC   0x00001000
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_10BPCC  0x00002000
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_12BPCC  0x00004000
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_8BPCC   0x00008000
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_10BPCC  0x00010000
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_12BPCC  0x00020000
+
+#define ADL_TF_sRGB           0x0001
+#define ADL_TF_BT709          0x0002
+#define ADL_TF_PQ2084         0x0004
+#define ADL_TF_PQ2084_INTERIM 0x0008
+#define ADL_TF_LINEAR_0_1     0x0010
+#define ADL_TF_LINEAR_0_125   0x0020
+#define ADL_TF_DOLBYVISION    0x0040
+#define ADL_TF_GAMMA_22       0x0080
+
+#define ADL_CS_sRGB           0x0001
+#define ADL_CS_BT601          0x0002
+#define ADL_CS_BT709          0x0004
+#define ADL_CS_BT2020         0x0008
+#define ADL_CS_ADOBE          0x0010
+#define ADL_CS_P3             0x0020
+#define ADL_CS_scRGB_MS_REF   0x0040
+#define ADL_CS_DISPLAY_NATIVE 0x0080
+#define ADL_CS_APP_CONTROL    0x0100
+#define ADL_CS_DOLBYVISION    0x0200
+
+typedef struct ADLDDCInfo2
+{
+    int ulSize;
+    int ulSupportsDDC;
+    int ulManufacturerID;
+    int ulProductID;
+    char cDisplayName[ADL_MAX_DISPLAY_NAME];
+    int ulMaxHResolution;
+    int ulMaxVResolution;
+    int ulMaxRefresh;
+    int ulPTMCx;
+    int ulPTMCy;
+    int ulPTMRefreshRate;
+    int ulDDCInfoFlag;
+    int bPackedPixelSupported;
+    int iPanelPixelFormat;
+    int ulSerialID;
+    int ulMinLuminanceData;
+    int ulAvgLuminanceData;
+    int ulMaxLuminanceData;
+    int iSupportedTransferFunction;
+    int iSupportedColorSpace;
+    int iNativeDisplayChromaticityRedX;
+    int iNativeDisplayChromaticityRedY;
+    int iNativeDisplayChromaticityGreenX;
+    int iNativeDisplayChromaticityGreenY;
+    int iNativeDisplayChromaticityBlueX;
+    int iNativeDisplayChromaticityBlueY;
+    int iNativeDisplayChromaticityWhitePointX;
+    int iNativeDisplayChromaticityWhitePointY;
+    int iDiffuseScreenReflectance;
+    int iSpecularScreenReflectance;
+    int iSupportedHDR;
+    int iFreesyncFlags;
+    int ulMinLuminanceNoDimmingData;
+    int ulMaxBacklightMaxLuminanceData;
+    int ulMinBacklightMaxLuminanceData;
+    int ulMaxBacklightMinLuminanceData;
+    int ulMinBacklightMinLuminanceData;
+    int ulScreenWidth;
+    int ulScreenHeight;
+    int iReserved[2];
+} ADLDDCInfo2;
+
 static const ADLVersionsInfo version = {
     "99.19.02-230831a-396538C-AMD-Software-Adrenalin-Edition",
     "",
@@ -706,6 +789,55 @@ int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLD
     return ADL2_Display_DisplayInfo_Get(default_ctx, adapter_index, num_displays, info, force_detect);
 }
 
+static int chroma_value_conv(float v)
+{
+    return lrintf(v * 10000);
+}
+
+int CDECL ADL2_Display_DDCInfo2_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int display_index, ADLDDCInfo2 *info)
+{
+    DXGI_OUTPUT_DESC1 *desc;
+    struct monitor *display;
+    struct gpu *gpu;
+    FIXME("ctx %p, adapter_index %d, display_index %d, info %p semi-stub.\n", ctx, adapter_index,
+            display_index, info);
+    memset(info, 0, sizeof(*info));
+    info->ulSize = sizeof(*info);
+
+    if (adapter_index >= ctx->adapter_count) return ADL_ERR_INVALID_PARAM;
+    gpu = ctx->adapters[adapter_index].gpu;
+    if (display_index >= gpu->display_count) return ADL_OK;
+    display = &gpu->displays[display_index];
+
+    desc = &display->dxgi_output_desc;
+    info->ulSupportsDDC = 1;
+    strcpy(info->cDisplayName, display->display_name);
+    info->iSupportedHDR = (desc->ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020);
+    info->iPanelPixelFormat = ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888;
+    info->iSupportedTransferFunction = ADL_TF_sRGB | ADL_TF_LINEAR_0_1;
+    info->iSupportedColorSpace = ADL_CS_sRGB;
+    if (info->iSupportedHDR)
+    {
+        TRACE("HDR is supported.\n");
+        info->iPanelPixelFormat |= ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB101010;
+        info->iSupportedTransferFunction |= ADL_TF_PQ2084;
+        info->iSupportedColorSpace |= ADL_CS_BT2020;
+    }
+    info->iNativeDisplayChromaticityRedX = chroma_value_conv(desc->RedPrimary[0]);
+    info->iNativeDisplayChromaticityRedY = chroma_value_conv(desc->RedPrimary[1]);
+    info->iNativeDisplayChromaticityGreenX = chroma_value_conv(desc->GreenPrimary[0]);
+    info->iNativeDisplayChromaticityGreenY = chroma_value_conv(desc->GreenPrimary[1]);
+    info->iNativeDisplayChromaticityBlueX = chroma_value_conv(desc->BluePrimary[0]);
+    info->iNativeDisplayChromaticityBlueY = chroma_value_conv(desc->BluePrimary[1]);
+    info->iNativeDisplayChromaticityWhitePointX = chroma_value_conv(desc->WhitePoint[0]);
+    info->iNativeDisplayChromaticityWhitePointY = chroma_value_conv(desc->WhitePoint[1]);
+
+    info->ulMinLuminanceData = desc->MinLuminance;
+    info->ulMaxLuminanceData = desc->MaxLuminance;
+    info->ulAvgLuminanceData = desc->MaxFullFrameLuminance;
+    return ADL_OK;
+}
+
 int CDECL ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
 {
     FIXME("adapter %d, preffered %p, num_comb %p, comb %p stub!\n", adapter_index, preffered, num_comb, comb);


From eaa6930f8b9f4162761e24d5ec61474606cce526 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 2 Oct 2025 18:26:48 -0600
Subject: [PATCH] atiadlxx: Add stub for ADL2_Adapter_Graphic_Core_Info_Get().

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   |  2 +-
 dlls/atiadlxx/atiadlxx_main.c | 14 ++++++++++++++
 2 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index ed7dd7069c4..5d44a20eb29 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -82,7 +82,7 @@
 @ stub ADL2_Adapter_FrameMetrics_Stop
 @ stub ADL2_Adapter_Gamma_Get
 @ stub ADL2_Adapter_Gamma_Set
-@ stub ADL2_Adapter_Graphic_Core_Info_Get
+@ cdecl ADL2_Adapter_Graphic_Core_Info_Get(ptr long ptr)
 @ stub ADL2_Adapter_HBC_Caps
 @ stub ADL2_Adapter_HBM_ECC_UC_Check
 @ stub ADL2_Adapter_Headless_Get
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index fc3ec1dc14b..c77bfd2ea3b 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -808,6 +808,20 @@ int CDECL ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock,
     return ADL2_Adapter_ObservedClockInfo_Get(default_ctx, adapter_index, core_clock, memory_clock);
 }
 
+
+int CDECL ADL2_Adapter_Graphic_Core_Info_Get(ADL_CONTEXT_HANDLE context, int adapter_index, ADLGraphicCoreInfo *info)
+{
+    FIXME("context %p, adapter_index %d, info %p stub.\n", context, adapter_index, info);
+
+    memset(info, 0, sizeof(*info));
+    info->iNumPEsPerCU = 1000;
+    info->iNumCUs = 1000;
+    info->iGCGen = 100;
+    info->iNumROPs = 10000;
+    info->iNumSIMDs = 10000;
+    return ADL_OK;
+}
+
 /* documented in the "Linux Specific APIs" section, present and used on Windows */
 int CDECL ADL2_Adapter_MemoryInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, ADLMemoryInfo *mem_info)
 {


From 8816f73b6cb2f2a94ba528164850f6f529f0a438 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 2 Oct 2025 18:44:58 -0600
Subject: [PATCH] atiadlxx: Implement ADL2_Adapter_Active_Get().

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   | 2 +-
 dlls/atiadlxx/atiadlxx_main.c | 9 +++++++++
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 86465541681..ed7dd7069c4 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -14,7 +14,7 @@
 @ stub ADL2_Adapter_ASICInfo_Get
 @ stub ADL2_Adapter_Accessibility_Get
 @ stub ADL2_Adapter_AceDefaults_Restore
-@ stub ADL2_Adapter_Active_Get
+@ cdecl ADL2_Adapter_Active_Get(ptr long ptr)
 @ stub ADL2_Adapter_Active_Set
 @ stub ADL2_Adapter_Active_SetPrefer
 @ cdecl ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index e96e631ce85..fc3ec1dc14b 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -657,6 +657,15 @@ int CDECL ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE ctx, ADLAdapterInfo
     return adapter_info_get(ctx, *info, ctx->adapter_count * sizeof(**info));
 }
 
+int CDECL ADL2_Adapter_Active_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *status)
+{
+    TRACE("ctx %p, adapter_index %d, status %p.\n", ctx, adapter_index, status);
+
+    if (adapter_index >= ctx->adapter_count) return ADL_ERR_INVALID_ADL_IDX;
+    *status = ctx->adapters[adapter_index].active;
+    return ADL_OK;
+}
+
 int CDECL ADL2_Display_DisplayInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
 {
     struct gpu *gpu;


From bd5dd1b6a1ef67176256399684aaa7f52fde9dda Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 29 Sep 2025 18:42:14 -0600
Subject: [PATCH] atiadlxx: Query adapter config at context creation.

CW-Bug-Id: #25998
---
 dlls/atiadlxx/Makefile.in     |   2 +-
 dlls/atiadlxx/atiadlxx_main.c | 520 ++++++++++++++++++++++++++--------
 2 files changed, 410 insertions(+), 112 deletions(-)

diff --git a/dlls/atiadlxx/Makefile.in b/dlls/atiadlxx/Makefile.in
index cc6b51bf2bc..85cda94c29d 100644
--- a/dlls/atiadlxx/Makefile.in
+++ b/dlls/atiadlxx/Makefile.in
@@ -1,6 +1,6 @@
 EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE = atiadlxx.dll
-IMPORTS = dxgi
+IMPORTS = user32 dxgi cfgmgr32
 
 EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
 
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 710d9048f3c..e96e631ce85 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -7,12 +7,17 @@
 #define COBJMACROS
 #include "windef.h"
 #include "winbase.h"
+#include "wingdi.h"
 #include "winuser.h"
 #include "objbase.h"
 #include "initguid.h"
 #include "wine/debug.h"
+#include "cfgmgr32.h"
+#include "devpkey.h"
+#include "ntddvdeo.h"
+#include "math.h"
 
-#include "dxgi.h"
+#include "dxgi1_6.h"
 
 #define MAX_GPUS 64
 #define VENDOR_AMD 0x1002
@@ -32,6 +37,8 @@
 #define ADL_ASIC_DISCRETE    (1 << 0)
 #define ADL_ASIC_MASK        0xAF
 
+#define ADL_MAX_PATH 256
+
 enum ADLPlatForm
 {
     GRAPHICS_PLATFORM_DESKTOP  = 0,
@@ -57,16 +64,6 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 }
 
 typedef void *(CALLBACK *ADL_MAIN_MALLOC_CALLBACK)(int);
-typedef struct adl_context
-{
-    ADL_MAIN_MALLOC_CALLBACK malloc;
-    IDXGIFactory *dxgi_factory;
-}
-*ADL_CONTEXT_HANDLE;
-
-static ADL_CONTEXT_HANDLE default_ctx;
-
-#define ADL_MAX_PATH 256
 
 typedef struct ADLVersionsInfo
 {
@@ -101,6 +98,27 @@ typedef struct ADLAdapterInfo {
     int iOSDisplayIndex;
 } ADLAdapterInfo, *LPADLAdapterInfo;
 
+typedef struct ADLGraphicCoreInfo
+{
+    int iGCGen;
+
+    union
+    {
+        int iNumCUs;
+        int iNumWGPs;
+    };
+
+    union
+    {
+        int iNumPEsPerCU;
+        int iNumPEsPerWGP;
+    };
+
+    int iNumSIMDs;
+    int iNumROPs;
+    int iReserved[11];
+} ADLGraphicCoreInfo;
+
 typedef struct ADLDisplayID
 {
     int iDisplayLogicalIndex;
@@ -176,6 +194,8 @@ typedef struct ADLDisplayMap
     int iDisplayMapValue;
 } ADLDisplayMap, *LPADLDisplayMap;
 
+#define ADL_MAX_DISPLAY_NAME 256
+
 static const ADLVersionsInfo version = {
     "99.19.02-230831a-396538C-AMD-Software-Adrenalin-Edition",
     "",
@@ -189,32 +209,342 @@ static const ADLVersionsInfoX2 version2 = {
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
-int CDECL ADL2_Main_Control_Destroy(ADL_CONTEXT_HANDLE context)
+static void ascii_from_unicode( char *dst, const WCHAR *src )
+{
+    while ((*dst++ = *src++))
+        ;
+}
+
+DEFINE_DEVPROPKEY(DEVPROPKEY_GPU_LUID, 0x60b193cb, 0x5276, 0x4d0f, 0x96, 0xfc, 0xf1, 0x73, 0xab, 0xad, 0x3e, 0xc6, 2);
+
+struct monitor
+{
+    UINT32 output_id;
+    int logical_adapter_index;
+    int physical_adapter_index;
+    char display_name[ADL_MAX_PATH];
+    DXGI_OUTPUT_DESC1 dxgi_output_desc;
+    BOOL found_dxgi_output;
+    DISPLAYCONFIG_SOURCE_MODE mode;
+    DISPLAYCONFIG_RATIONAL refresh_rate;
+    DISPLAYCONFIG_ROTATION rotation;
+};
+
+struct gpu
+{
+    LUID luid;
+    char device_string[256];
+    char device_path[256];
+    struct monitor *displays;
+    UINT32 vendor_id;
+    int display_count;
+    int adapter_count;
+    int first_adapter_index;
+    DXGI_ADAPTER_DESC1 dxgi_adapter_desc;
+};
+
+struct adapter
+{
+    struct gpu *gpu;
+    struct monitor *display;
+    UINT32 source_id;
+    char gdi_device_name[32];
+    char driver_path[256];
+    BOOL active;
+};
+
+typedef struct adl_context
+{
+    ADL_MAIN_MALLOC_CALLBACK malloc;
+
+    struct gpu *gpus;
+    int gpu_count;
+
+    struct adapter *adapters;
+    int adapter_count;
+}
+*ADL_CONTEXT_HANDLE;
+
+static ADL_CONTEXT_HANDLE default_ctx;
+
+int CDECL ADL2_Main_Control_Destroy(ADL_CONTEXT_HANDLE ctx)
 {
-    TRACE("context %p stub.\n", context);
+    int i;
 
-    if (!context) return ADL_ERR;
-    if (context->dxgi_factory)
-        IUnknown_Release(context->dxgi_factory);
-    if (context == default_ctx) default_ctx = NULL;
-    free(context);
+    TRACE("ctx %p.\n", ctx);
+
+    if (!ctx) return ADL_ERR;
+    if (ctx == default_ctx) default_ctx = NULL;
+
+    for (i = 0; i < ctx->gpu_count; ++i)
+        free(ctx->gpus[i].displays);
+
+    free(ctx->adapters);
+    free(ctx->gpus);
+    free(ctx);
     return ADL_OK;
 }
 
+static int init_info(ADL_CONTEXT_HANDLE ctx)
+{
+    DISPLAYCONFIG_PATH_INFO *paths = NULL;
+    DISPLAYCONFIG_MODE_INFO *modes = NULL;
+    DXGI_ADAPTER_DESC1 adapter_desc;
+    DXGI_OUTPUT_DESC1 output_desc1;
+    IDXGIFactory1 *dxgi_factory = NULL;
+    UINT32 path_count, mode_count;
+    WCHAR *gpu_iface_list = NULL, *p;
+    IDXGIAdapter1 *dxgi_adapter;
+    IDXGIOutput *output;
+    DISPLAY_DEVICEA dd;
+    IDXGIOutput6 *output6;
+    unsigned int i, j, k, count;
+    int err = ADL_ERR;
+    struct monitor *display;
+    struct adapter *adapter;
+    struct gpu *gpu;
+    char buffer[256];
+    WCHAR instance_id[256];
+    DEVPROPTYPE type;
+    DWORD ret;
+    ULONG size;
+
+    if (FAILED(CreateDXGIFactory1(&IID_IDXGIFactory1, (void**)&dxgi_factory)))
+        goto done;
+
+    if (CM_Get_Device_Interface_List_SizeW(&size, &GUID_DEVINTERFACE_DISPLAY_ADAPTER, NULL, CM_GET_DEVICE_INTERFACE_LIST_PRESENT))
+        goto done;
+
+    gpu_iface_list = malloc(size * sizeof(*gpu_iface_list));
+    if (CM_Get_Device_Interface_ListW(&GUID_DEVINTERFACE_DISPLAY_ADAPTER, NULL, gpu_iface_list, size, CM_GET_DEVICE_INTERFACE_LIST_PRESENT))
+        goto done;
+
+    /* Get GPUs. */
+    p = gpu_iface_list;
+    count = ctx->adapter_count;
+    while (*p)
+    {
+        DEVINST devinst;
+
+        ascii_from_unicode(buffer, p);
+        ctx->gpus = realloc(ctx->gpus, (ctx->gpu_count + 1) * sizeof(*ctx->gpus));
+        memset(&ctx->gpus[ctx->gpu_count], 0, sizeof(*ctx->gpus));
+        strcpy(ctx->gpus[ctx->gpu_count].device_path, buffer);
+        size = ARRAY_SIZE(instance_id);
+        if (CM_Get_Device_Interface_PropertyW(p, &DEVPKEY_Device_InstanceId, &type, (BYTE *)instance_id, &size, 0))
+            continue;
+        if (CM_Locate_DevNodeW(&devinst, instance_id, 0))
+            continue;
+        size = sizeof(ctx->gpus[i].luid);
+        if (CM_Get_DevNode_PropertyW(devinst, &DEVPROPKEY_GPU_LUID, &type, &ctx->gpus[ctx->gpu_count].luid, &size, 0))
+            continue;
+
+        ++ctx->gpu_count;
+        p += wcslen(p) + 1;
+    }
+    ctx->adapter_count = count;
+    free(gpu_iface_list);
+
+    /* Get adapters and monitors. */
+    do
+    {
+        if (GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &path_count, &mode_count))
+            goto done;
+
+        paths = realloc(paths, sizeof(*paths) * path_count);
+        modes = realloc(modes, sizeof(*modes) * mode_count);
+
+        ret = QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &path_count, paths, &mode_count, modes, NULL);
+    } while (ret == ERROR_INSUFFICIENT_BUFFER);
+    if (ret) goto done;
+
+    for (i = 0; i < path_count; ++i)
+    {
+        DISPLAYCONFIG_SOURCE_DEVICE_NAME source_name;
+        DISPLAYCONFIG_TARGET_DEVICE_NAME target_name;
+
+        for (j = 0; j < ctx->gpu_count; ++j)
+        {
+            if (!memcmp(&ctx->gpus[j].luid, &paths[i].sourceInfo.adapterId, sizeof(ctx->gpus[j].luid))) break;
+        }
+        if (j == ctx->gpu_count)
+        {
+            ERR("Adapter luid %#x:%#x not found in gpu list.\n",
+                    (int)paths[i].sourceInfo.adapterId.HighPart, (int)paths[i].sourceInfo.adapterId.LowPart );
+            continue;
+        }
+        gpu = &ctx->gpus[j];
+
+        for (j = 0; j < ctx->adapter_count; ++j)
+        {
+            if (ctx->adapters[j].source_id == paths[i].sourceInfo.id) break;
+        }
+        if (j == ctx->adapter_count)
+        {
+            ctx->adapters = realloc(ctx->adapters, (j + 1) * sizeof(*ctx->adapters));
+            adapter = &ctx->adapters[j];
+            memset(adapter, 0, sizeof(*ctx->adapters));
+            adapter->gpu = gpu;
+            adapter->source_id = paths[i].sourceInfo.id;
+
+            source_name.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME;
+            source_name.header.size = sizeof(source_name);
+            source_name.header.adapterId = paths[i].sourceInfo.adapterId;
+            source_name.header.id = paths[i].sourceInfo.id;
+            if (DisplayConfigGetDeviceInfo(&source_name.header)) goto done;
+            ascii_from_unicode(adapter->gdi_device_name, source_name.viewGdiDeviceName);
+
+            if (!gpu->adapter_count) gpu->first_adapter_index = ctx->adapter_count;
+            ++ctx->adapter_count;
+            ++gpu->adapter_count;
+        }
+        else adapter = &ctx->adapters[j];
+
+        for (j = 0; j < gpu->display_count; ++j)
+        {
+            if (paths[i].targetInfo.id == gpu->displays[j].output_id) break;
+        }
+
+        if (j == gpu->display_count)
+        {
+            gpu->displays = realloc(gpu->displays, (gpu->display_count + 1) * sizeof(*gpu->displays));
+            display = &gpu->displays[gpu->display_count];
+            memset(display, 0, sizeof(*gpu->displays));
+            display->output_id = paths[i].targetInfo.id;
+            display->physical_adapter_index = gpu->first_adapter_index;
+            display->logical_adapter_index = adapter - &ctx->adapters[0];
+            target_name.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME;
+            target_name.header.size = sizeof(target_name);
+            target_name.header.adapterId = paths[i].targetInfo.adapterId;
+            target_name.header.id = paths[i].targetInfo.id;
+            if (DisplayConfigGetDeviceInfo(&target_name.header)) goto done;
+            ascii_from_unicode(display->display_name, target_name.monitorFriendlyDeviceName);
+            display->mode = modes[paths[i].sourceInfo.modeInfoIdx].sourceMode;
+            display->refresh_rate = paths[i].targetInfo.refreshRate;
+            display->rotation = paths[i].targetInfo.rotation;
+            if (adapter->display)
+                ERR("Display is already assigned for adapter %s.\n", adapter->gdi_device_name);
+            adapter->display = display;
+            adapter->active = TRUE;
+            ++gpu->display_count;
+        }
+    }
+
+    /* Get driver path and device name for adapters. */
+    dd.cb = sizeof(dd);
+    for (i = 0; EnumDisplayDevicesA(NULL, i, &dd, EDD_GET_DEVICE_INTERFACE_NAME); ++i)
+    {
+        for (j = 0; j < ctx->adapter_count; ++j)
+        {
+            if (stricmp(ctx->adapters[i].gdi_device_name, dd.DeviceName)) continue;
+            strcpy(ctx->adapters[i].gpu->device_string, dd.DeviceString);
+            strcpy(ctx->adapters[i].driver_path, dd.DeviceKey);
+        }
+    }
+
+    /* Fake adapters for GPUs without outputs. */
+    for (i = 0; i < ctx->gpu_count; ++i)
+    {
+        gpu = &ctx->gpus[i];
+        if (gpu->adapter_count) continue;
+        ctx->adapters = realloc(ctx->adapters, (ctx->adapter_count + 1) * sizeof(*ctx->adapters));
+        adapter = &ctx->adapters[ctx->adapter_count];
+        memset(adapter, 0, sizeof(*ctx->adapters));
+        adapter->gpu = gpu;
+        gpu->first_adapter_index = ctx->adapter_count;
+        ++gpu->adapter_count;
+        ++ctx->adapter_count;
+        sprintf(adapter->gdi_device_name, "\\\\.\\DISPLAY%d", ctx->adapter_count);
+        ERR("No adapter for GPU %s, using fake %s.\n", gpu->device_string, adapter->gdi_device_name);
+    }
+
+    /* Initialize info queried from dxgi. */
+    for (i = 0; !IDXGIFactory1_EnumAdapters1(dxgi_factory, i, &dxgi_adapter); ++i)
+    {
+        if (FAILED(IDXGIAdapter1_GetDesc1(dxgi_adapter, &adapter_desc)))
+        {
+            IDXGIAdapter1_Release(dxgi_adapter);
+            continue;
+        }
+
+        for (j = 0; j < ctx->gpu_count; ++j)
+        {
+            if (memcmp(&adapter_desc.AdapterLuid, &ctx->gpus[j].luid, sizeof(adapter_desc.AdapterLuid))) continue;
+            gpu = &ctx->gpus[j];
+            gpu->dxgi_adapter_desc = adapter_desc;
+            gpu->vendor_id = adapter_desc.VendorId;
+            if (!gpu->device_string[0])
+                ascii_from_unicode(gpu->device_string, adapter_desc.Description);
+            break;
+        }
+        if (j == ctx->gpu_count)
+            ERR("Could not find gpu for dxgi adapter device %s.\n", debugstr_w(adapter_desc.Description));
+
+        for (j = 0; !IDXGIAdapter1_EnumOutputs(dxgi_adapter, j, &output); ++j)
+        {
+            if (IDXGIOutput_QueryInterface(output, &IID_IDXGIOutput6, (void**)&output6))
+            {
+                IDXGIOutput_Release(output);
+                continue;
+            }
+            if (IDXGIOutput6_GetDesc1(output6, &output_desc1))
+            {
+                IDXGIOutput_Release(output);
+                IDXGIOutput6_Release(output6);
+                continue;
+            }
+
+            ascii_from_unicode(buffer, output_desc1.DeviceName);
+            for (k = 0; k < ctx->adapter_count; ++k)
+            {
+                adapter = &ctx->adapters[k];
+                if (stricmp(buffer, adapter->gdi_device_name) || !adapter->display) continue;
+                adapter->display->dxgi_output_desc = output_desc1;
+                adapter->display->found_dxgi_output = TRUE;
+                adapter->active = TRUE;
+                break;
+            }
+            if (k == ctx->adapter_count)
+                ERR("No adapter found for dxgi output %s.\n", debugstr_w(output_desc1.DeviceName));
+            IDXGIOutput6_Release(output6);
+            IDXGIOutput_Release(output);
+        }
+        IDXGIAdapter1_Release(dxgi_adapter);
+    }
+    for (i = 0; i < ctx->adapter_count; ++i)
+    {
+        if (!(display = ctx->adapters[i].display)) continue;
+        if (!display->found_dxgi_output)
+        {
+            ERR("No dxgi output found for display %d, %s, adapter %d, %s.\n",
+                    i, display->display_name, display->logical_adapter_index,
+                    ctx->adapters[i].gdi_device_name);
+        }
+    }
+    err = ADL_OK;
+
+done:
+    free(paths);
+    free(modes);
+    if (dxgi_factory) IDXGIFactory1_Release(dxgi_factory);
+    return err;
+}
+
 int CDECL ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
 {
     ADL_CONTEXT_HANDLE ctx;
+    int ret;
 
     TRACE("cb %p, arg %d, ptr %p.\n", cb, arg, ptr);
 
     ctx = calloc( 1, sizeof(**ptr));
-    if (FAILED(CreateDXGIFactory(&IID_IDXGIFactory, (void**)&ctx->dxgi_factory)))
+    ctx->malloc = cb;
+    if ((ret = init_info(ctx)))
     {
-        free(ctx);
-        return ADL_ERR;
+        ERR("Initialization failed.\n");
+        ADL2_Main_Control_Destroy(ctx);
+        return ret;
     }
-
-    ctx->malloc = cb;
     if (default_ctx) ADL2_Main_Control_Destroy(default_ctx);
     default_ctx = ctx;
     *ptr = ctx;
@@ -224,7 +554,7 @@ int CDECL ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CON
 
 int CDECL ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
 {
-    TRACE("cb %p, arg %d stub!\n", cb, arg);
+    TRACE("cb %p, arg %d.\n", cb, arg);
 
     return ADL2_Main_Control_Create(cb, arg, &default_ctx);
 }
@@ -238,17 +568,9 @@ int CDECL ADL_Main_Control_Destroy(void)
 
 int CDECL ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE ctx, int *count)
 {
-    IDXGIAdapter *adapter;
-
     TRACE("ctx %p, count %p.\n", ctx, count);
 
-    *count = 0;
-    while (SUCCEEDED(IDXGIFactory_EnumAdapters(ctx->dxgi_factory, *count, &adapter)))
-    {
-        (*count)++;
-        IUnknown_Release(adapter);
-    }
-
+    *count = ctx->adapter_count;
     TRACE("*count = %d\n", *count);
     return ADL_OK;
 }
@@ -274,21 +596,6 @@ int CDECL ADL_Adapter_NumberOfAdapters_Get(int *count)
     return ADL2_Adapter_NumberOfAdapters_Get(default_ctx, count);
 }
 
-static int get_adapter_desc(ADL_CONTEXT_HANDLE ctx, int adapter_index, DXGI_ADAPTER_DESC *desc)
-{
-    IDXGIAdapter *adapter;
-    HRESULT hr;
-
-    if (FAILED(IDXGIFactory_EnumAdapters(ctx->dxgi_factory, adapter_index, &adapter)))
-        return ADL_ERR;
-
-    hr = IDXGIAdapter_GetDesc(adapter, desc);
-
-    IUnknown_Release(adapter);
-
-    return SUCCEEDED(hr) ? ADL_OK : ADL_ERR;
-}
-
 /* yep, seriously */
 static int convert_vendor_id(int id)
 {
@@ -300,7 +607,7 @@ static int convert_vendor_id(int id)
 static int adapter_info_get(ADL_CONTEXT_HANDLE ctx, ADLAdapterInfo *adapters, int input_size)
 {
     int i, count = input_size / sizeof(*adapters);
-    DXGI_ADAPTER_DESC adapter_desc;
+    char buffer[256], *p;
 
     memset(adapters, 0, input_size);
 
@@ -308,71 +615,74 @@ static int adapter_info_get(ADL_CONTEXT_HANDLE ctx, ADLAdapterInfo *adapters, in
     {
         adapters[i].iSize = sizeof(ADLAdapterInfo);
         adapters[i].iAdapterIndex = i;
-
-        if (get_adapter_desc(ctx, i, &adapter_desc) != ADL_OK)
-            return ADL_ERR;
-
-        adapters[i].iVendorID = convert_vendor_id(adapter_desc.VendorId);
+        adapters[i].iOSDisplayIndex = i;
+
+        strcpy(buffer, ctx->adapters[i].gpu->device_path + 4);
+        if ((p = strrchr(buffer, '#'))) *p = 0;
+        for (p = buffer; *p; ++p)
+            if (*p == '#') *p = '\\';
+        if (ctx->adapters[i].source_id)
+            sprintf(adapters[i].strPNPString, "%s&%02d", buffer, ctx->adapters[i].source_id + 1);
+        else
+            strcpy(adapters[i].strPNPString, buffer);
+        strcpy(adapters[i].strUDID, adapters[i].strPNPString);
+        for (p = adapters[i].strUDID; *p; ++p)
+            if (*p == '\\') *p = '_';
+        *p++ = 'A';
+        *p = 0;
+
+        adapters[i].iVendorID = convert_vendor_id(ctx->adapters[i].gpu->vendor_id);
+        strcpy(adapters[i].strAdapterName, ctx->adapters[i].gpu->device_string);
+        strcpy(adapters[i].strDisplayName, ctx->adapters[i].gdi_device_name);
+        strcpy(adapters[i].strDriverPath, ctx->adapters[i].driver_path);
     }
     return ADL_OK;
 }
 
 int CDECL ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
 {
-    int count;
-
-    FIXME("adapters %p, input_size %d, stub!\n", adapters, input_size);
-
-    ADL_Adapter_NumberOfAdapters_Get(&count);
+    TRACE("adapters %p, input_size %d.\n", adapters, input_size);
 
     if (!adapters) return ADL_ERR_INVALID_PARAM;
-    if (input_size != count * sizeof(ADLAdapterInfo)) return ADL_ERR_INVALID_PARAM;
+    if (input_size != default_ctx->adapter_count * sizeof(ADLAdapterInfo)) return ADL_ERR_INVALID_PARAM;
 
     return adapter_info_get(default_ctx, adapters, input_size);
 }
 
 int CDECL ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE ctx, ADLAdapterInfo **info)
 {
-    int count;
-
     TRACE("ctx %p, info %p.\n", ctx, info);
-    ADL2_Adapter_NumberOfAdapters_Get(ctx, &count);
-    *info = ctx->malloc( count * sizeof(**info) );
-    return adapter_info_get(ctx, *info, count * sizeof(**info));
+
+    *info = ctx->malloc( ctx->adapter_count * sizeof(**info) );
+    return adapter_info_get(ctx, *info, ctx->adapter_count * sizeof(**info));
 }
 
 int CDECL ADL2_Display_DisplayInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
 {
-    IDXGIAdapter *adapter;
-    IDXGIOutput *output;
+    struct gpu *gpu;
     int i;
 
-    FIXME("adapter %d, num_displays %p, info %p stub!\n", adapter_index, num_displays, info);
+    TRACE("adapter %d, num_displays %p, info %p.\n", adapter_index, num_displays, info);
 
     if (info == NULL || num_displays == NULL) return ADL_ERR_NULL_POINTER;
 
-    if (FAILED(IDXGIFactory_EnumAdapters(ctx->dxgi_factory, adapter_index, &adapter)))
-        return ADL_ERR_INVALID_PARAM;
+    if (adapter_index >= ctx->adapter_count) return ADL_ERR_INVALID_PARAM;
 
-    *num_displays = 0;
-
-    while (SUCCEEDED(IDXGIAdapter_EnumOutputs(adapter, *num_displays, &output)))
-    {
-        (*num_displays)++;
-        IUnknown_Release(output);
-    }
-
-    IUnknown_Release(adapter);
-
-    if (*num_displays == 0)
-        return ADL_OK;
+    gpu = ctx->adapters[adapter_index].gpu;
+    *num_displays = gpu->display_count;
 
     *info = ctx->malloc(*num_displays * sizeof(**info));
     memset(*info, 0, *num_displays * sizeof(**info));
 
     for (i = 0; i < *num_displays; i++)
     {
+        (*info)[i].displayID.iDisplayLogicalAdapterIndex = gpu->displays[i].logical_adapter_index;
         (*info)[i].displayID.iDisplayLogicalIndex = i;
+        (*info)[i].displayID.iDisplayPhysicalAdapterIndex = gpu->displays[i].physical_adapter_index;
+        (*info)[i].displayID.iDisplayPhysicalIndex = i;
+        strcpy((*info)[i].strDisplayName, gpu->displays[i].display_name);
+        (*info)[i].iDisplayType = 2 /* ADL_DT_LCD_PANEL */;
+        (*info)[i].iDisplayOutputType = 4 /* ADL_DOT_DIGITAL */;
         (*info)[i].iDisplayInfoValue = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
         (*info)[i].iDisplayInfoMask = (*info)[i].iDisplayInfoValue;
     }
@@ -407,17 +717,12 @@ int CDECL ADL_Adapter_Crossfire_Get(int adapter_index, ADLCrossfireComb *comb, A
 
 int CDECL ADL2_Adapter_ASICFamilyType_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *asic_type, int *valids)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
-
-    FIXME("adapter %d, asic_type %p, valids %p, stub!\n", adapter_index, asic_type, valids);
+    FIXME("adapter %d, asic_type %p, valids %p, stub.\n", adapter_index, asic_type, valids);
 
     if (asic_type == NULL || valids == NULL)
-        return  ADL_ERR_NULL_POINTER;
+        return ADL_ERR_NULL_POINTER;
 
-    if (get_adapter_desc(ctx, adapter_index, &adapter_desc) != ADL_OK)
-        return ADL_ERR_INVALID_ADL_IDX;
-
-    if (adapter_desc.VendorId != VENDOR_AMD)
+    if (ctx->adapters[adapter_index].gpu->vendor_id != VENDOR_AMD)
         return ADL_ERR_NOT_SUPPORTED;
 
     *asic_type = ADL_ASIC_DISCRETE;
@@ -472,13 +777,11 @@ static int get_max_clock(const char *clock, int default_value)
 /* the name and documentation suggests that this returns current freqs, but it's actually max */
 int CDECL ADL2_Adapter_ObservedClockInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *core_clock, int *memory_clock)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
-
-    FIXME("adapter %d, core_clock %p, memory_clock %p, stub!\n", adapter_index, core_clock, memory_clock);
+    FIXME("ctx %p, adapter %d, core_clock %p, memory_clock %p, stub.\n", ctx, adapter_index, core_clock, memory_clock);
 
     if (core_clock == NULL || memory_clock == NULL) return ADL_ERR;
-    if (get_adapter_desc(ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
-    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR_INVALID_ADL_IDX;
+    if (adapter_index >= ctx->adapter_count) return ADL_ERR_INVALID_ADL_IDX;
+    if (ctx->adapters[adapter_index].gpu->vendor_id != VENDOR_AMD) return ADL_ERR_INVALID_ADL_IDX;
 
     /* default values based on RX580 */
     *core_clock = get_max_clock("sclk", 1350);
@@ -499,15 +802,13 @@ int CDECL ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock,
 /* documented in the "Linux Specific APIs" section, present and used on Windows */
 int CDECL ADL2_Adapter_MemoryInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, ADLMemoryInfo *mem_info)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
-
-    FIXME("adapter %d, mem_info %p stub!\n", adapter_index, mem_info);
+    FIXME("ctx %p, adapter %d, mem_info %p stub.\n", ctx, adapter_index, mem_info);
 
     if (mem_info == NULL) return ADL_ERR_NULL_POINTER;
-    if (get_adapter_desc(ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
-    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR;
+    if (adapter_index >= ctx->adapter_count) return ADL_ERR_INVALID_ADL_IDX;
+    if (ctx->adapters[adapter_index].gpu->vendor_id != VENDOR_AMD) return ADL_ERR;
 
-    mem_info->iMemorySize = adapter_desc.DedicatedVideoMemory;
+    mem_info->iMemorySize = ctx->adapters[adapter_index].gpu->dxgi_adapter_desc.DedicatedVideoMemory;
     mem_info->iMemoryBandwidth = 256000; /* not exposed on Linux, probably needs a lookup table */
 
     TRACE("iMemoryBandwidth %s, iMemorySize %s\n",
@@ -525,22 +826,19 @@ int CDECL ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
 
 int CDECL ADL2_Graphics_Platform_Get(ADL_CONTEXT_HANDLE ctx, int *platform)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
-    int count, i;
+    int i;
 
-    FIXME("platform %p, stub!\n", platform);
+    FIXME("platform %p, stub.\n", platform);
 
     *platform = GRAPHICS_PLATFORM_UNKNOWN;
 
-    ADL_Adapter_NumberOfAdapters_Get(&count);
-
-    for (i = 0; i < count; i ++)
+    for (i = 0; i < ctx->gpu_count; ++i)
     {
-        if (get_adapter_desc(ctx, i, &adapter_desc) != ADL_OK)
-            continue;
-
-        if (adapter_desc.VendorId == VENDOR_AMD)
+        if (ctx->gpus[i].vendor_id == VENDOR_AMD)
+        {
             *platform = GRAPHICS_PLATFORM_DESKTOP;
+            break;
+        }
     }
 
     /* NOTE: The real value can be obtained by doing:


From 22d7732881bf5ef3fcfe20e5cd591d0d3e285cc6 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 2 Oct 2025 18:37:38 -0600
Subject: [PATCH] atiadlxx: Add v2 versions of implemented ADL stubs.

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   | 12 +++----
 dlls/atiadlxx/atiadlxx_main.c | 61 ++++++++++++++++++++++++++++-------
 2 files changed, 56 insertions(+), 17 deletions(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 2bc7a109c58..86465541681 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -10,7 +10,7 @@
 @ stub ADL2_AdapterLimitation_Caps
 @ stub ADL2_AdapterX2_Caps
 @ stub ADL2_Adapter_AMDAndNonAMDDIsplayClone_Get
-@ stub ADL2_Adapter_ASICFamilyType_Get
+@ cdecl ADL2_Adapter_ASICFamilyType_Get(ptr long ptr ptr)
 @ stub ADL2_Adapter_ASICInfo_Get
 @ stub ADL2_Adapter_Accessibility_Get
 @ stub ADL2_Adapter_AceDefaults_Restore
@@ -49,7 +49,7 @@
 @ stub ADL2_Adapter_CrossdisplayInfo_Get
 @ stub ADL2_Adapter_CrossdisplayInfo_Set
 @ stub ADL2_Adapter_CrossfireX2_Get
-@ stub ADL2_Adapter_Crossfire_Caps
+@ cdecl ADL2_Adapter_Crossfire_Caps(ptr long ptr ptr ptr)
 @ stub ADL2_Adapter_Crossfire_Get
 @ stub ADL2_Adapter_Crossfire_Set
 @ stub ADL2_Adapter_DefaultAudioChannelTable_Load
@@ -94,14 +94,14 @@
 @ stub ADL2_Adapter_MVPU_Set
 @ stub ADL2_Adapter_MaxCursorSize_Get
 @ stub ADL2_Adapter_MemoryInfo2_Get
-@ stub ADL2_Adapter_MemoryInfo_Get
+@ cdecl ADL2_Adapter_MemoryInfo_Get(ptr long ptr)
 @ stub ADL2_Adapter_MirabilisSupport_Get
 @ stub ADL2_Adapter_ModeSwitch
 @ stub ADL2_Adapter_ModeTimingOverride_Caps
 @ stub ADL2_Adapter_Modes_ReEnumerate
 @ stub ADL2_Adapter_NumberOfActivatableSources_Get
 @ cdecl ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
-@ stub ADL2_Adapter_ObservedClockInfo_Get
+@ cdecl ADL2_Adapter_ObservedClockInfo_Get(ptr long ptr ptr)
 @ stub ADL2_Adapter_PMLog_Start
 @ stub ADL2_Adapter_PMLog_Stop
 @ stub ADL2_Adapter_PMLog_Support_Get
@@ -257,7 +257,7 @@
 @ stub ADL2_Display_DisplayContent_Cap
 @ stub ADL2_Display_DisplayContent_Get
 @ stub ADL2_Display_DisplayContent_Set
-@ stub ADL2_Display_DisplayInfo_Get
+@ cdecl ADL2_Display_DisplayInfo_Get(ptr long ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfigX2_Set
 @ stub ADL2_Display_DisplayMapConfig_Get
 @ stub ADL2_Display_DisplayMapConfig_PossibleAddAndRemove
@@ -431,7 +431,7 @@
 @ stub ADL2_Graphics_IsDetachableGraphicsPlatform_Get
 @ stub ADL2_Graphics_IsGfx9AndAbove
 @ stub ADL2_Graphics_MantleVersion_Get
-@ stub ADL2_Graphics_Platform_Get
+@ cdecl ADL2_Graphics_Platform_Get(ptr ptr)
 @ cdecl ADL2_Graphics_VersionsX2_Get(ptr ptr)
 @ stub ADL2_Graphics_Versions_Get
 @ stub ADL2_Graphics_VulkanVersion_Get
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 7226469422a..710d9048f3c 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -341,7 +341,7 @@ int CDECL ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE ctx, ADLAdapterInfo
     return adapter_info_get(ctx, *info, count * sizeof(**info));
 }
 
-int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
+int CDECL ADL2_Display_DisplayInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
 {
     IDXGIAdapter *adapter;
     IDXGIOutput *output;
@@ -351,7 +351,7 @@ int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLD
 
     if (info == NULL || num_displays == NULL) return ADL_ERR_NULL_POINTER;
 
-    if (FAILED(IDXGIFactory_EnumAdapters(default_ctx->dxgi_factory, adapter_index, &adapter)))
+    if (FAILED(IDXGIFactory_EnumAdapters(ctx->dxgi_factory, adapter_index, &adapter)))
         return ADL_ERR_INVALID_PARAM;
 
     *num_displays = 0;
@@ -367,7 +367,7 @@ int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLD
     if (*num_displays == 0)
         return ADL_OK;
 
-    *info = default_ctx->malloc(*num_displays * sizeof(**info));
+    *info = ctx->malloc(*num_displays * sizeof(**info));
     memset(*info, 0, *num_displays * sizeof(**info));
 
     for (i = 0; i < *num_displays; i++)
@@ -380,19 +380,32 @@ int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLD
     return ADL_OK;
 }
 
+int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
+{
+    TRACE(".\n");
+
+    return ADL2_Display_DisplayInfo_Get(default_ctx, adapter_index, num_displays, info, force_detect);
+}
+
 int CDECL ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
 {
     FIXME("adapter %d, preffered %p, num_comb %p, comb %p stub!\n", adapter_index, preffered, num_comb, comb);
     return ADL_ERR;
 }
 
+int CDECL ADL2_Adapter_Crossfire_Caps(ADL_CONTEXT_HANDLE context, int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
+{
+    FIXME("context %p, adapter %d, preffered %p, num_comb %p, comb %p stub!\n", context, adapter_index, preffered, num_comb, comb);
+    return ADL_ERR;
+}
+
 int CDECL ADL_Adapter_Crossfire_Get(int adapter_index, ADLCrossfireComb *comb, ADLCrossfireInfo *info)
 {
     FIXME("adapter %d, comb %p, info %p, stub!\n", adapter_index, comb, info);
     return ADL_ERR;
 }
 
-int CDECL ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int *valids)
+int CDECL ADL2_Adapter_ASICFamilyType_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *asic_type, int *valids)
 {
     DXGI_ADAPTER_DESC adapter_desc;
 
@@ -401,7 +414,7 @@ int CDECL ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int
     if (asic_type == NULL || valids == NULL)
         return  ADL_ERR_NULL_POINTER;
 
-    if (get_adapter_desc(default_ctx, adapter_index, &adapter_desc) != ADL_OK)
+    if (get_adapter_desc(ctx, adapter_index, &adapter_desc) != ADL_OK)
         return ADL_ERR_INVALID_ADL_IDX;
 
     if (adapter_desc.VendorId != VENDOR_AMD)
@@ -413,6 +426,12 @@ int CDECL ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int
     return ADL_OK;
 }
 
+int CDECL ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int *valids)
+{
+    TRACE("adapter %d, asic_type %p, valids %p.\n", adapter_index, asic_type, valids);
+    return ADL2_Adapter_ASICFamilyType_Get(default_ctx, adapter_index, asic_type, valids);
+}
+
 static int get_max_clock(const char *clock, int default_value)
 {
     char path[MAX_PATH], line[256];
@@ -451,14 +470,14 @@ static int get_max_clock(const char *clock, int default_value)
 
 /* documented in the "Linux Specific APIs" section, present and used on Windows */
 /* the name and documentation suggests that this returns current freqs, but it's actually max */
-int CDECL ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock, int *memory_clock)
+int CDECL ADL2_Adapter_ObservedClockInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, int *core_clock, int *memory_clock)
 {
     DXGI_ADAPTER_DESC adapter_desc;
 
     FIXME("adapter %d, core_clock %p, memory_clock %p, stub!\n", adapter_index, core_clock, memory_clock);
 
     if (core_clock == NULL || memory_clock == NULL) return ADL_ERR;
-    if (get_adapter_desc(default_ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
+    if (get_adapter_desc(ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
     if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR_INVALID_ADL_IDX;
 
     /* default values based on RX580 */
@@ -470,15 +489,22 @@ int CDECL ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock,
     return ADL_OK;
 }
 
+int CDECL ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock, int *memory_clock)
+{
+    TRACE("adapter_index %d, core_clock %p, memory_clock %p.\n", adapter_index, core_clock, memory_clock);
+
+    return ADL2_Adapter_ObservedClockInfo_Get(default_ctx, adapter_index, core_clock, memory_clock);
+}
+
 /* documented in the "Linux Specific APIs" section, present and used on Windows */
-int CDECL ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
+int CDECL ADL2_Adapter_MemoryInfo_Get(ADL_CONTEXT_HANDLE ctx, int adapter_index, ADLMemoryInfo *mem_info)
 {
     DXGI_ADAPTER_DESC adapter_desc;
 
     FIXME("adapter %d, mem_info %p stub!\n", adapter_index, mem_info);
 
     if (mem_info == NULL) return ADL_ERR_NULL_POINTER;
-    if (get_adapter_desc(default_ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
+    if (get_adapter_desc(ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
     if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR;
 
     mem_info->iMemorySize = adapter_desc.DedicatedVideoMemory;
@@ -490,7 +516,14 @@ int CDECL ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
     return ADL_OK;
 }
 
-int CDECL ADL_Graphics_Platform_Get(int *platform)
+int CDECL ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
+{
+    TRACE("adapter_index %d, mem_info %p.\n", adapter_index, mem_info);
+
+    return ADL2_Adapter_MemoryInfo_Get(default_ctx, adapter_index, mem_info);
+}
+
+int CDECL ADL2_Graphics_Platform_Get(ADL_CONTEXT_HANDLE ctx, int *platform)
 {
     DXGI_ADAPTER_DESC adapter_desc;
     int count, i;
@@ -503,7 +536,7 @@ int CDECL ADL_Graphics_Platform_Get(int *platform)
 
     for (i = 0; i < count; i ++)
     {
-        if (get_adapter_desc(default_ctx, i, &adapter_desc) != ADL_OK)
+        if (get_adapter_desc(ctx, i, &adapter_desc) != ADL_OK)
             continue;
 
         if (adapter_desc.VendorId == VENDOR_AMD)
@@ -518,6 +551,12 @@ int CDECL ADL_Graphics_Platform_Get(int *platform)
     return ADL_OK;
 }
 
+int CDECL ADL_Graphics_Platform_Get(int *platform)
+{
+    TRACE("platform %p.\n", platform);
+
+    return ADL2_Graphics_Platform_Get(default_ctx, platform);
+}
 
 int CDECL ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
         int *display_target_count, ADLDisplayTarget **display_targets, int options)


From 960b85b804c7a12cca314be60bf02d8a8cb51941 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 29 Sep 2025 19:23:39 -0600
Subject: [PATCH] atiadlxx: Add semi-stub for ADL2_Adapter_AdapterInfoX2_Get().

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   |  2 +-
 dlls/atiadlxx/atiadlxx_main.c | 82 ++++++++++++++++++++---------------
 2 files changed, 49 insertions(+), 35 deletions(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 88e08fa3e9f..2bc7a109c58 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -17,7 +17,7 @@
 @ stub ADL2_Adapter_Active_Get
 @ stub ADL2_Adapter_Active_Set
 @ stub ADL2_Adapter_Active_SetPrefer
-@ stub ADL2_Adapter_AdapterInfoX2_Get
+@ cdecl ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
 @ stub ADL2_Adapter_AdapterInfoX3_Get
 @ stub ADL2_Adapter_AdapterInfoX4_Get
 @ stub ADL2_Adapter_AdapterInfo_Get
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 07a2be11160..7226469422a 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -236,52 +236,50 @@ int CDECL ADL_Main_Control_Destroy(void)
     return ADL2_Main_Control_Destroy(default_ctx);
 }
 
-int CDECL ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
+int CDECL ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE ctx, int *count)
 {
-    FIXME("ptr %p, count %p stub!\n", ptr, count);
+    IDXGIAdapter *adapter;
+
+    TRACE("ctx %p, count %p.\n", ctx, count);
 
     *count = 0;
+    while (SUCCEEDED(IDXGIFactory_EnumAdapters(ctx->dxgi_factory, *count, &adapter)))
+    {
+        (*count)++;
+        IUnknown_Release(adapter);
+    }
 
+    TRACE("*count = %d\n", *count);
     return ADL_OK;
 }
 
-int CDECL ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE *ptr, ADLVersionsInfoX2 *ver)
+int CDECL ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE ptr, ADLVersionsInfoX2 *ver)
 {
-    FIXME("ptr %p, ver %p stub!\n", ptr, ver);
+    TRACE("ptr %p, ver %p.\n", ptr, ver);
     memcpy(ver, &version2, sizeof(version2));
     return ADL_OK;
 }
 
 int CDECL ADL_Graphics_Versions_Get(ADLVersionsInfo *ver)
 {
-    FIXME("ver %p stub!\n", ver);
+    TRACE("ver %p.\n", ver);
     memcpy(ver, &version, sizeof(version));
     return ADL_OK;
 }
 
 int CDECL ADL_Adapter_NumberOfAdapters_Get(int *count)
 {
-    IDXGIAdapter *adapter;
-
-    FIXME("count %p stub!\n", count);
-
-    *count = 0;
-    while (SUCCEEDED(IDXGIFactory_EnumAdapters(default_ctx->dxgi_factory, *count, &adapter)))
-    {
-        (*count)++;
-        IUnknown_Release(adapter);
-    }
+    TRACE("count %p.\n", count);
 
-    TRACE("*count = %d\n", *count);
-    return ADL_OK;
+    return ADL2_Adapter_NumberOfAdapters_Get(default_ctx, count);
 }
 
-static int get_adapter_desc(int adapter_index, DXGI_ADAPTER_DESC *desc)
+static int get_adapter_desc(ADL_CONTEXT_HANDLE ctx, int adapter_index, DXGI_ADAPTER_DESC *desc)
 {
     IDXGIAdapter *adapter;
     HRESULT hr;
 
-    if (FAILED(IDXGIFactory_EnumAdapters(default_ctx->dxgi_factory, adapter_index, &adapter)))
+    if (FAILED(IDXGIFactory_EnumAdapters(ctx->dxgi_factory, adapter_index, &adapter)))
         return ADL_ERR;
 
     hr = IDXGIAdapter_GetDesc(adapter, desc);
@@ -299,18 +297,11 @@ static int convert_vendor_id(int id)
     return atoi(str);
 }
 
-int CDECL ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
+static int adapter_info_get(ADL_CONTEXT_HANDLE ctx, ADLAdapterInfo *adapters, int input_size)
 {
-    int count, i;
+    int i, count = input_size / sizeof(*adapters);
     DXGI_ADAPTER_DESC adapter_desc;
 
-    FIXME("adapters %p, input_size %d, stub!\n", adapters, input_size);
-
-    ADL_Adapter_NumberOfAdapters_Get(&count);
-
-    if (!adapters) return ADL_ERR_INVALID_PARAM;
-    if (input_size != count * sizeof(ADLAdapterInfo)) return ADL_ERR_INVALID_PARAM;
-
     memset(adapters, 0, input_size);
 
     for (i = 0; i < count; i++)
@@ -318,15 +309,38 @@ int CDECL ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
         adapters[i].iSize = sizeof(ADLAdapterInfo);
         adapters[i].iAdapterIndex = i;
 
-        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
+        if (get_adapter_desc(ctx, i, &adapter_desc) != ADL_OK)
             return ADL_ERR;
 
         adapters[i].iVendorID = convert_vendor_id(adapter_desc.VendorId);
     }
-
     return ADL_OK;
 }
 
+int CDECL ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
+{
+    int count;
+
+    FIXME("adapters %p, input_size %d, stub!\n", adapters, input_size);
+
+    ADL_Adapter_NumberOfAdapters_Get(&count);
+
+    if (!adapters) return ADL_ERR_INVALID_PARAM;
+    if (input_size != count * sizeof(ADLAdapterInfo)) return ADL_ERR_INVALID_PARAM;
+
+    return adapter_info_get(default_ctx, adapters, input_size);
+}
+
+int CDECL ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE ctx, ADLAdapterInfo **info)
+{
+    int count;
+
+    TRACE("ctx %p, info %p.\n", ctx, info);
+    ADL2_Adapter_NumberOfAdapters_Get(ctx, &count);
+    *info = ctx->malloc( count * sizeof(**info) );
+    return adapter_info_get(ctx, *info, count * sizeof(**info));
+}
+
 int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
 {
     IDXGIAdapter *adapter;
@@ -387,7 +401,7 @@ int CDECL ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int
     if (asic_type == NULL || valids == NULL)
         return  ADL_ERR_NULL_POINTER;
 
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK)
+    if (get_adapter_desc(default_ctx, adapter_index, &adapter_desc) != ADL_OK)
         return ADL_ERR_INVALID_ADL_IDX;
 
     if (adapter_desc.VendorId != VENDOR_AMD)
@@ -444,7 +458,7 @@ int CDECL ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock,
     FIXME("adapter %d, core_clock %p, memory_clock %p, stub!\n", adapter_index, core_clock, memory_clock);
 
     if (core_clock == NULL || memory_clock == NULL) return ADL_ERR;
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
+    if (get_adapter_desc(default_ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
     if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR_INVALID_ADL_IDX;
 
     /* default values based on RX580 */
@@ -464,7 +478,7 @@ int CDECL ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
     FIXME("adapter %d, mem_info %p stub!\n", adapter_index, mem_info);
 
     if (mem_info == NULL) return ADL_ERR_NULL_POINTER;
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
+    if (get_adapter_desc(default_ctx, adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
     if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR;
 
     mem_info->iMemorySize = adapter_desc.DedicatedVideoMemory;
@@ -489,7 +503,7 @@ int CDECL ADL_Graphics_Platform_Get(int *platform)
 
     for (i = 0; i < count; i ++)
     {
-        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
+        if (get_adapter_desc(default_ctx, i, &adapter_desc) != ADL_OK)
             continue;
 
         if (adapter_desc.VendorId == VENDOR_AMD)


From a3d6304e5fe61ee40dbddb483f70154c6bc51604 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 29 Sep 2025 19:18:56 -0600
Subject: [PATCH] atiadlxx: Add ADL2_Main_Control_Destroy() and manage context
 through ADL2.

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   |  2 +-
 dlls/atiadlxx/atiadlxx_main.c | 66 ++++++++++++++++++++++++-----------
 2 files changed, 46 insertions(+), 22 deletions(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 593ecc2256c..88e08fa3e9f 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -452,7 +452,7 @@
 @ stub ADL2_MMD_Video_Caps
 @ stub ADL2_Main_ControlX2_Create
 @ cdecl ADL2_Main_Control_Create(ptr long ptr)
-@ stub ADL2_Main_Control_Destroy
+@ cdecl ADL2_Main_Control_Destroy(ptr)
 @ stub ADL2_Main_Control_GetProcAddress
 @ stub ADL2_Main_Control_IsFunctionValid
 @ stub ADL2_Main_Control_Refresh
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index d011fa7c9f7..07a2be11160 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -23,6 +23,7 @@
 #define ADL_ERR_INVALID_ADL_IDX          -5
 #define ADL_ERR_NOT_SUPPORTED            -8
 #define ADL_ERR_NULL_POINTER             -9
+#define ADL_ERR_INVALID_CALLBACK         -11
 
 #define ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED            0x00000001
 #define ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED               0x00000002
@@ -39,8 +40,6 @@ enum ADLPlatForm
 #define GRAPHICS_PLATFORM_UNKNOWN -1
 
 
-static IDXGIFactory *dxgi_factory;
-
 WINE_DEFAULT_DEBUG_CHANNEL(atiadlxx);
 
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
@@ -58,9 +57,15 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 }
 
 typedef void *(CALLBACK *ADL_MAIN_MALLOC_CALLBACK)(int);
-typedef void *ADL_CONTEXT_HANDLE;
+typedef struct adl_context
+{
+    ADL_MAIN_MALLOC_CALLBACK malloc;
+    IDXGIFactory *dxgi_factory;
+}
+*ADL_CONTEXT_HANDLE;
+
+static ADL_CONTEXT_HANDLE default_ctx;
 
-ADL_MAIN_MALLOC_CALLBACK adl_malloc;
 #define ADL_MAX_PATH 256
 
 typedef struct ADLVersionsInfo
@@ -184,32 +189,51 @@ static const ADLVersionsInfoX2 version2 = {
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
-int CDECL ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
+int CDECL ADL2_Main_Control_Destroy(ADL_CONTEXT_HANDLE context)
 {
-    FIXME("cb %p, arg %d, ptr %p stub!\n", cb, arg, ptr);
+    TRACE("context %p stub.\n", context);
+
+    if (!context) return ADL_ERR;
+    if (context->dxgi_factory)
+        IUnknown_Release(context->dxgi_factory);
+    if (context == default_ctx) default_ctx = NULL;
+    free(context);
     return ADL_OK;
 }
 
-int CDECL ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
+int CDECL ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
 {
-    FIXME("cb %p, arg %d stub!\n", cb, arg);
-    adl_malloc = cb;
+    ADL_CONTEXT_HANDLE ctx;
 
+    TRACE("cb %p, arg %d, ptr %p.\n", cb, arg, ptr);
 
-    if (SUCCEEDED(CreateDXGIFactory(&IID_IDXGIFactory, (void**) &dxgi_factory)))
-        return ADL_OK;
-    else
+    ctx = calloc( 1, sizeof(**ptr));
+    if (FAILED(CreateDXGIFactory(&IID_IDXGIFactory, (void**)&ctx->dxgi_factory)))
+    {
+        free(ctx);
         return ADL_ERR;
+    }
+
+    ctx->malloc = cb;
+    if (default_ctx) ADL2_Main_Control_Destroy(default_ctx);
+    default_ctx = ctx;
+    *ptr = ctx;
+    TRACE("-> %p.\n", *ptr);
+    return ADL_OK;
 }
 
-int CDECL ADL_Main_Control_Destroy(void)
+int CDECL ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
 {
-    FIXME("stub!\n");
+    TRACE("cb %p, arg %d stub!\n", cb, arg);
 
-    if (dxgi_factory != NULL)
-        IUnknown_Release(dxgi_factory);
+    return ADL2_Main_Control_Create(cb, arg, &default_ctx);
+}
 
-    return ADL_OK;
+int CDECL ADL_Main_Control_Destroy(void)
+{
+    TRACE(".\n");
+
+    return ADL2_Main_Control_Destroy(default_ctx);
 }
 
 int CDECL ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
@@ -242,7 +266,7 @@ int CDECL ADL_Adapter_NumberOfAdapters_Get(int *count)
     FIXME("count %p stub!\n", count);
 
     *count = 0;
-    while (SUCCEEDED(IDXGIFactory_EnumAdapters(dxgi_factory, *count, &adapter)))
+    while (SUCCEEDED(IDXGIFactory_EnumAdapters(default_ctx->dxgi_factory, *count, &adapter)))
     {
         (*count)++;
         IUnknown_Release(adapter);
@@ -257,7 +281,7 @@ static int get_adapter_desc(int adapter_index, DXGI_ADAPTER_DESC *desc)
     IDXGIAdapter *adapter;
     HRESULT hr;
 
-    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
+    if (FAILED(IDXGIFactory_EnumAdapters(default_ctx->dxgi_factory, adapter_index, &adapter)))
         return ADL_ERR;
 
     hr = IDXGIAdapter_GetDesc(adapter, desc);
@@ -313,7 +337,7 @@ int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLD
 
     if (info == NULL || num_displays == NULL) return ADL_ERR_NULL_POINTER;
 
-    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
+    if (FAILED(IDXGIFactory_EnumAdapters(default_ctx->dxgi_factory, adapter_index, &adapter)))
         return ADL_ERR_INVALID_PARAM;
 
     *num_displays = 0;
@@ -329,7 +353,7 @@ int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLD
     if (*num_displays == 0)
         return ADL_OK;
 
-    *info = adl_malloc(*num_displays * sizeof(**info));
+    *info = default_ctx->malloc(*num_displays * sizeof(**info));
     memset(*info, 0, *num_displays * sizeof(**info));
 
     for (i = 0; i < *num_displays; i++)


From 0652a5ad3d966c196cde2dcb902e55f69c7e8ad9 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 29 Sep 2025 19:11:05 -0600
Subject: [PATCH] atiadlxx: Make ADL functions CDECL.

CW-Bug-Id: #25998
---
 dlls/atiadlxx/atiadlxx.spec   | 32 ++++++++++++++++----------------
 dlls/atiadlxx/atiadlxx_main.c | 32 ++++++++++++++++----------------
 2 files changed, 32 insertions(+), 32 deletions(-)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 1e447f38ded..593ecc2256c 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -100,7 +100,7 @@
 @ stub ADL2_Adapter_ModeTimingOverride_Caps
 @ stub ADL2_Adapter_Modes_ReEnumerate
 @ stub ADL2_Adapter_NumberOfActivatableSources_Get
-@ stdcall ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
+@ cdecl ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
 @ stub ADL2_Adapter_ObservedClockInfo_Get
 @ stub ADL2_Adapter_PMLog_Start
 @ stub ADL2_Adapter_PMLog_Stop
@@ -432,7 +432,7 @@
 @ stub ADL2_Graphics_IsGfx9AndAbove
 @ stub ADL2_Graphics_MantleVersion_Get
 @ stub ADL2_Graphics_Platform_Get
-@ stdcall ADL2_Graphics_VersionsX2_Get(ptr ptr)
+@ cdecl ADL2_Graphics_VersionsX2_Get(ptr ptr)
 @ stub ADL2_Graphics_Versions_Get
 @ stub ADL2_Graphics_VulkanVersion_Get
 @ stub ADL2_HybridGraphicsGPU_Set
@@ -451,7 +451,7 @@
 @ stub ADL2_MMD_VideoColor_Set
 @ stub ADL2_MMD_Video_Caps
 @ stub ADL2_Main_ControlX2_Create
-@ stdcall ADL2_Main_Control_Create(ptr long ptr)
+@ cdecl ADL2_Main_Control_Create(ptr long ptr)
 @ stub ADL2_Main_Control_Destroy
 @ stub ADL2_Main_Control_GetProcAddress
 @ stub ADL2_Main_Control_IsFunctionValid
@@ -681,14 +681,14 @@
 @ stub ADL_APO_AudioDelay_Set
 @ stub ADL_AdapterLimitation_Caps
 @ stub ADL_AdapterX2_Caps
-@ stdcall ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
+@ cdecl ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
 @ stub ADL_Adapter_ASICInfo_Get
 @ stub ADL_Adapter_Accessibility_Get
 @ stub ADL_Adapter_Active_Get
 @ stub ADL_Adapter_Active_Set
 @ stub ADL_Adapter_Active_SetPrefer
 @ stub ADL_Adapter_AdapterInfoX2_Get
-@ stdcall ADL_Adapter_AdapterInfo_Get(ptr long)
+@ cdecl ADL_Adapter_AdapterInfo_Get(ptr long)
 @ stub ADL_Adapter_AdapterList_Disable
 @ stub ADL_Adapter_Aspects_Get
 @ stub ADL_Adapter_AudioChannelSplitConfiguration_Get
@@ -714,8 +714,8 @@
 @ stub ADL_Adapter_CrossdisplayInfo_Get
 @ stub ADL_Adapter_CrossdisplayInfo_Set
 @ stub ADL_Adapter_CrossfireX2_Get
-@ stdcall ADL_Adapter_Crossfire_Caps(long ptr ptr ptr)
-@ stdcall ADL_Adapter_Crossfire_Get(long ptr ptr)
+@ cdecl ADL_Adapter_Crossfire_Caps(long ptr ptr ptr)
+@ cdecl ADL_Adapter_Crossfire_Get(long ptr ptr)
 @ stub ADL_Adapter_Crossfire_Set
 @ stub ADL_Adapter_DefaultAudioChannelTable_Load
 @ stub ADL_Adapter_DisplayAudioEndpoint_Enable
@@ -736,14 +736,14 @@
 @ stub ADL_Adapter_LocalDisplayState_Get
 @ stub ADL_Adapter_MaxCursorSize_Get
 @ stub ADL_Adapter_MemoryInfo2_Get
-@ stdcall ADL_Adapter_MemoryInfo_Get(long ptr)
+@ cdecl ADL_Adapter_MemoryInfo_Get(long ptr)
 @ stub ADL_Adapter_MirabilisSupport_Get
 @ stub ADL_Adapter_ModeSwitch
 @ stub ADL_Adapter_ModeTimingOverride_Caps
 @ stub ADL_Adapter_Modes_ReEnumerate
 @ stub ADL_Adapter_NumberOfActivatableSources_Get
-@ stdcall ADL_Adapter_NumberOfAdapters_Get(ptr)
-@ stdcall ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
+@ cdecl ADL_Adapter_NumberOfAdapters_Get(ptr)
+@ cdecl ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
 @ stub ADL_Adapter_ObservedGameClockInfo_Get
 @ stub ADL_Adapter_Primary_Get
 @ stub ADL_Adapter_Primary_Set
@@ -844,8 +844,8 @@
 @ stub ADL_Display_DisplayContent_Cap
 @ stub ADL_Display_DisplayContent_Get
 @ stub ADL_Display_DisplayContent_Set
-@ stdcall ADL_Display_DisplayInfo_Get(long long ptr long)
-@ stdcall ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
+@ cdecl ADL_Display_DisplayInfo_Get(long long ptr long)
+@ cdecl ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
 @ stub ADL_Display_DisplayMapConfig_PossibleAddAndRemove
 @ stub ADL_Display_DisplayMapConfig_Set
 @ stub ADL_Display_DisplayMapConfig_Validate
@@ -969,8 +969,8 @@
 @ stub ADL_Display_WriteAndReadI2CLargePayload
 @ stub ADL_Display_WriteAndReadI2CRev_Get
 @ stub ADL_Flush_Driver_Data
-@ stdcall ADL_Graphics_Platform_Get(ptr)
-@ stdcall ADL_Graphics_Versions_Get(ptr)
+@ cdecl ADL_Graphics_Platform_Get(ptr)
+@ cdecl ADL_Graphics_Versions_Get(ptr)
 @ stub ADL_MMD_FeatureList_Get
 @ stub ADL_MMD_FeatureValuesX2_Get
 @ stub ADL_MMD_FeatureValuesX2_Set
@@ -985,8 +985,8 @@
 @ stub ADL_MMD_VideoColor_Set
 @ stub ADL_MMD_Video_Caps
 @ stub ADL_Main_ControlX2_Create
-@ stdcall ADL_Main_Control_Create(ptr long)
-@ stdcall ADL_Main_Control_Destroy()
+@ cdecl ADL_Main_Control_Create(ptr long)
+@ cdecl ADL_Main_Control_Destroy()
 @ stub ADL_Main_Control_GetProcAddress
 @ stub ADL_Main_Control_IsFunctionValid
 @ stub ADL_Main_Control_Refresh
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 9399025f94b..d011fa7c9f7 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -184,13 +184,13 @@ static const ADLVersionsInfoX2 version2 = {
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
-int WINAPI ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
+int CDECL ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
 {
     FIXME("cb %p, arg %d, ptr %p stub!\n", cb, arg, ptr);
     return ADL_OK;
 }
 
-int WINAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
+int CDECL ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
 {
     FIXME("cb %p, arg %d stub!\n", cb, arg);
     adl_malloc = cb;
@@ -202,7 +202,7 @@ int WINAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
         return ADL_ERR;
 }
 
-int WINAPI ADL_Main_Control_Destroy(void)
+int CDECL ADL_Main_Control_Destroy(void)
 {
     FIXME("stub!\n");
 
@@ -212,7 +212,7 @@ int WINAPI ADL_Main_Control_Destroy(void)
     return ADL_OK;
 }
 
-int WINAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
+int CDECL ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
 {
     FIXME("ptr %p, count %p stub!\n", ptr, count);
 
@@ -221,21 +221,21 @@ int WINAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count
     return ADL_OK;
 }
 
-int WINAPI ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE *ptr, ADLVersionsInfoX2 *ver)
+int CDECL ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE *ptr, ADLVersionsInfoX2 *ver)
 {
     FIXME("ptr %p, ver %p stub!\n", ptr, ver);
     memcpy(ver, &version2, sizeof(version2));
     return ADL_OK;
 }
 
-int WINAPI ADL_Graphics_Versions_Get(ADLVersionsInfo *ver)
+int CDECL ADL_Graphics_Versions_Get(ADLVersionsInfo *ver)
 {
     FIXME("ver %p stub!\n", ver);
     memcpy(ver, &version, sizeof(version));
     return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_NumberOfAdapters_Get(int *count)
+int CDECL ADL_Adapter_NumberOfAdapters_Get(int *count)
 {
     IDXGIAdapter *adapter;
 
@@ -275,7 +275,7 @@ static int convert_vendor_id(int id)
     return atoi(str);
 }
 
-int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
+int CDECL ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
 {
     int count, i;
     DXGI_ADAPTER_DESC adapter_desc;
@@ -303,7 +303,7 @@ int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
     return ADL_OK;
 }
 
-int WINAPI ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
+int CDECL ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
 {
     IDXGIAdapter *adapter;
     IDXGIOutput *output;
@@ -342,19 +342,19 @@ int WINAPI ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADL
     return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
+int CDECL ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
 {
     FIXME("adapter %d, preffered %p, num_comb %p, comb %p stub!\n", adapter_index, preffered, num_comb, comb);
     return ADL_ERR;
 }
 
-int WINAPI ADL_Adapter_Crossfire_Get(int adapter_index, ADLCrossfireComb *comb, ADLCrossfireInfo *info)
+int CDECL ADL_Adapter_Crossfire_Get(int adapter_index, ADLCrossfireComb *comb, ADLCrossfireInfo *info)
 {
     FIXME("adapter %d, comb %p, info %p, stub!\n", adapter_index, comb, info);
     return ADL_ERR;
 }
 
-int WINAPI ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int *valids)
+int CDECL ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int *valids)
 {
     DXGI_ADAPTER_DESC adapter_desc;
 
@@ -413,7 +413,7 @@ static int get_max_clock(const char *clock, int default_value)
 
 /* documented in the "Linux Specific APIs" section, present and used on Windows */
 /* the name and documentation suggests that this returns current freqs, but it's actually max */
-int WINAPI ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock, int *memory_clock)
+int CDECL ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock, int *memory_clock)
 {
     DXGI_ADAPTER_DESC adapter_desc;
 
@@ -433,7 +433,7 @@ int WINAPI ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock,
 }
 
 /* documented in the "Linux Specific APIs" section, present and used on Windows */
-int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
+int CDECL ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
 {
     DXGI_ADAPTER_DESC adapter_desc;
 
@@ -452,7 +452,7 @@ int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info
     return ADL_OK;
 }
 
-int WINAPI ADL_Graphics_Platform_Get(int *platform)
+int CDECL ADL_Graphics_Platform_Get(int *platform)
 {
     DXGI_ADAPTER_DESC adapter_desc;
     int count, i;
@@ -481,7 +481,7 @@ int WINAPI ADL_Graphics_Platform_Get(int *platform)
 }
 
 
-int WINAPI ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
+int CDECL ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
         int *display_target_count, ADLDisplayTarget **display_targets, int options)
 {
     FIXME("adapter_index %d, display_map_count %p, display_maps %p, "
